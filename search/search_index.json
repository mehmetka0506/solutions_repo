{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, though seemingly simple, presents a deep and rich structure when examined thoroughly. By studying how the range of a projectile depends on the launch angle, we reveal fundamental principles of kinematics and dynamics. Variables like initial velocity, gravitational acceleration, and launch height provide a broad variety of solutions, applicable to real-world situations such as sports, engineering, and space science. Theoretical Foundation Starting from the basic laws of motion, we can derive the projectile equations. Assume no air resistance and flat terrain. Let: \\(v_0\\) = Initial velocity \\(\\theta\\) = Angle of projection \\(g\\) = Gravitational acceleration The equations of motion are: $$ \\frac{d^2x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) $$ \\[ \\frac{d^2y}{dt^2} = -g \\quad \\Rightarrow \\quad \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\] Integrating these: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] Time of Flight Setting \\(y = 0\\) at landing: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2}gT^2 \\] Solving for T \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range Horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum Height The maximum vertical position: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] Observations Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , that is, \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effects of parameters \\(v_0\\) : Range increases quadratically with initial velocity. \\(g\\) : Range decreases inversely with gravitational acceleration. Launch height: Would modify the symmetry and the optimal angle if included. Practical Applications Sports: Finding the best launch angles for throws, shots, or kicks. Engineering: Ballistics calculations. Astrophysics: Launching satellites or projectiles from planetary surfaces. Including air resistance, wind, or launching from non-level terrain are real-world complications addressed with numerical methods. Implementation Below are Python scripts simulating projectile motion under the given scenarios. import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 1: 45\u00b0 angle, different velocities (30, 40, 50 m/s) import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 2: 50 m/s, different angles (15\u00b0, 45\u00b0, 75\u00b0) angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representations In the first plot, as initial velocity increases, range increases significantly. angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() In the second plot, \\(45^\\circ\\) provides the maximum range, while \\(15^\\circ\\) and \\(75^\\circ\\) give the same (shorter) range. Limitations and Extensions Limitations No air resistance considered. Flat launch and landing height assumed. Extensions Include air resistance: drag force proportional to velocity. Launch from or land on elevated platforms. Add wind effects. Summary Analyzing projectile motion illustrates fundamental physics while also introducing opportunities for deeper exploration using computational methods. Studying range as a function of launch angle helps us understand both idealized and real-world trajectories. Colab Link Colab - Problem 1 Simulation","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, though seemingly simple, presents a deep and rich structure when examined thoroughly. By studying how the range of a projectile depends on the launch angle, we reveal fundamental principles of kinematics and dynamics. Variables like initial velocity, gravitational acceleration, and launch height provide a broad variety of solutions, applicable to real-world situations such as sports, engineering, and space science.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"Starting from the basic laws of motion, we can derive the projectile equations. Assume no air resistance and flat terrain. Let: \\(v_0\\) = Initial velocity \\(\\theta\\) = Angle of projection \\(g\\) = Gravitational acceleration The equations of motion are: $$ \\frac{d^2x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) $$ \\[ \\frac{d^2y}{dt^2} = -g \\quad \\Rightarrow \\quad \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\] Integrating these: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Setting \\(y = 0\\) at landing: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2}gT^2 \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solving-for-t","text":"\\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Solving for T"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"Horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#maximum-height","text":"The maximum vertical position: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , that is, \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effects of parameters \\(v_0\\) : Range increases quadratically with initial velocity. \\(g\\) : Range decreases inversely with gravitational acceleration. Launch height: Would modify the symmetry and the optimal angle if included. Practical Applications Sports: Finding the best launch angles for throws, shots, or kicks. Engineering: Ballistics calculations. Astrophysics: Launching satellites or projectiles from planetary surfaces. Including air resistance, wind, or launching from non-level terrain are real-world complications addressed with numerical methods.","title":"Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"Below are Python scripts simulating projectile motion under the given scenarios. import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 1: 45\u00b0 angle, different velocities (30, 40, 50 m/s) import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 2: 50 m/s, different angles (15\u00b0, 45\u00b0, 75\u00b0) angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representations In the first plot, as initial velocity increases, range increases significantly. angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() In the second plot, \\(45^\\circ\\) provides the maximum range, while \\(15^\\circ\\) and \\(75^\\circ\\) give the same (shorter) range.","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"Limitations No air resistance considered. Flat launch and landing height assumed. Extensions Include air resistance: drag force proportional to velocity. Launch from or land on elevated platforms. Add wind effects.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Analyzing projectile motion illustrates fundamental physics while also introducing opportunities for deeper exploration using computational methods. Studying range as a function of launch angle helps us understand both idealized and real-world trajectories.","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab-link","text":"Colab - Problem 1 Simulation","title":"Colab Link"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Dynamics of a Forced Damped Pendulum: A Computational Exploration Motivation The forced damped pendulum is a key system in nonlinear dynamics. When damping and external periodic forces act on a pendulum, its behavior ranges from predictable oscillations to complex and chaotic motion. This diversity reflects many real-world systems \u2014 from electronics to biomechanics. By tuning parameters like the damping factor and the strength and frequency of the driving force, we observe phenomena such as resonance, quasiperiodicity, and transitions to chaos. These insights are fundamental in understanding oscillatory systems in engineering, physics, and nature. 1. Mathematical Framework Differential Equation The system is modeled by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement - \\(b\\) : damping coefficient - \\(g\\) : gravitational acceleration - \\(L\\) : length of pendulum - \\(A\\) : external driving amplitude - \\(\\omega\\) : angular frequency of the driving force Linear Approximation (Small Angle) For small angular displacements: \\[ \\sin\\theta \\approx \\theta \\] Reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This linear form simplifies simulation and helps analyze regular behavior before chaos emerges. 2. Parameter-Based Behavior Analysis We analyze system behavior by varying: Damping coefficient \\(b\\) Driving amplitude \\(A\\) Driving frequency \\(\\omega\\) This helps reveal: - Transition from underdamped to overdamped behavior - Resonance and amplification - Onset of chaotic regimes 3. Real-World Relevance This model describes: - Suspension systems in vehicles - Oscillating electrical circuits (e.g., RLC) - Structures under periodic stress - Biological movement patterns (gait dynamics) 4. Python Modeling Below is a simulation using solve_ivp from scipy.integrate to model pendulum behavior for different conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def dynamics(t, y, b, g, L, A, omega): theta, omega_ = y return [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] # Setup y0 = [0.15, 0.0] t_range = (0, 60) t_eval = np.linspace(*t_range, 1500) cases = [ {\"label\": \"Light Damping\", \"b\": 0.1, \"A\": 0.8, \"omega\": 1.0, \"color\": \"royalblue\"}, {\"label\": \"Critical Damping\", \"b\": 0.6, \"A\": 0.8, \"omega\": 1.0, \"color\": \"firebrick\"}, {\"label\": \"High Drive\", \"b\": 0.3, \"A\": 1.8, \"omega\": 3.0, \"color\": \"darkgreen\"}, ] g = 9.8 L = 1.0 fig, axes = plt.subplots(len(cases), 2, figsize=(12, 11)) for i, c in enumerate(cases): sol = solve_ivp( dynamics, t_range, y0, args=(c[\"b\"], g, L, c[\"A\"], c[\"omega\"]), t_eval=t_eval ) theta, omega_ = sol.y axes[i, 0].plot(sol.t, theta, color=c[\"color\"]) axes[i, 0].set_title(f'{c[\"label\"]} - \u03b8(t)') axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"\u03b8 (rad)\") axes[i, 0].grid() axes[i, 1].plot(theta, omega_, color=c[\"color\"]) axes[i, 1].set_title(f'{c[\"label\"]} - Phase Diagram') axes[i, 1].set_xlabel(\"\u03b8 (rad)\") axes[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axes[i, 1].grid() plt.tight_layout() plt.show() <<<<<<< HEAD ======= - 5. Simulation Outcomes Light Damping - Oscillations persist - Phase plot shows large elliptical orbits Critical Damping - Motion stabilizes quickly - System returns to equilibrium smoothly High Drive - Complex motion develops - Phase space suggests early chaos 6. Summary and Future Work This experiment demonstrates how driven damped pendulums can show both stability and complexity, depending on parameters. Possible extensions: - Generate bifurcation diagrams for varying \\(\\omega\\) - Add nonlinear damping - Analyze long-term chaos with Poincar\u00e9 maps These tools help bridge theory with systems seen in engineering, nature, and modern physics.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#dynamics-of-a-forced-damped-pendulum-a-computational-exploration","text":"","title":"Dynamics of a Forced Damped Pendulum: A Computational Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a key system in nonlinear dynamics. When damping and external periodic forces act on a pendulum, its behavior ranges from predictable oscillations to complex and chaotic motion. This diversity reflects many real-world systems \u2014 from electronics to biomechanics. By tuning parameters like the damping factor and the strength and frequency of the driving force, we observe phenomena such as resonance, quasiperiodicity, and transitions to chaos. These insights are fundamental in understanding oscillatory systems in engineering, physics, and nature.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-mathematical-framework","text":"","title":"1. Mathematical Framework"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The system is modeled by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement - \\(b\\) : damping coefficient - \\(g\\) : gravitational acceleration - \\(L\\) : length of pendulum - \\(A\\) : external driving amplitude - \\(\\omega\\) : angular frequency of the driving force","title":"Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#linear-approximation-small-angle","text":"For small angular displacements: \\[ \\sin\\theta \\approx \\theta \\] Reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This linear form simplifies simulation and helps analyze regular behavior before chaos emerges.","title":"Linear Approximation (Small Angle)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-parameter-based-behavior-analysis","text":"We analyze system behavior by varying: Damping coefficient \\(b\\) Driving amplitude \\(A\\) Driving frequency \\(\\omega\\) This helps reveal: - Transition from underdamped to overdamped behavior - Resonance and amplification - Onset of chaotic regimes","title":"2. Parameter-Based Behavior Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-relevance","text":"This model describes: - Suspension systems in vehicles - Oscillating electrical circuits (e.g., RLC) - Structures under periodic stress - Biological movement patterns (gait dynamics)","title":"3. Real-World Relevance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-modeling","text":"Below is a simulation using solve_ivp from scipy.integrate to model pendulum behavior for different conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def dynamics(t, y, b, g, L, A, omega): theta, omega_ = y return [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] # Setup y0 = [0.15, 0.0] t_range = (0, 60) t_eval = np.linspace(*t_range, 1500) cases = [ {\"label\": \"Light Damping\", \"b\": 0.1, \"A\": 0.8, \"omega\": 1.0, \"color\": \"royalblue\"}, {\"label\": \"Critical Damping\", \"b\": 0.6, \"A\": 0.8, \"omega\": 1.0, \"color\": \"firebrick\"}, {\"label\": \"High Drive\", \"b\": 0.3, \"A\": 1.8, \"omega\": 3.0, \"color\": \"darkgreen\"}, ] g = 9.8 L = 1.0 fig, axes = plt.subplots(len(cases), 2, figsize=(12, 11)) for i, c in enumerate(cases): sol = solve_ivp( dynamics, t_range, y0, args=(c[\"b\"], g, L, c[\"A\"], c[\"omega\"]), t_eval=t_eval ) theta, omega_ = sol.y axes[i, 0].plot(sol.t, theta, color=c[\"color\"]) axes[i, 0].set_title(f'{c[\"label\"]} - \u03b8(t)') axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"\u03b8 (rad)\") axes[i, 0].grid() axes[i, 1].plot(theta, omega_, color=c[\"color\"]) axes[i, 1].set_title(f'{c[\"label\"]} - Phase Diagram') axes[i, 1].set_xlabel(\"\u03b8 (rad)\") axes[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axes[i, 1].grid() plt.tight_layout() plt.show() <<<<<<< HEAD ======= -","title":"4. Python Modeling"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-simulation-outcomes","text":"Light Damping - Oscillations persist - Phase plot shows large elliptical orbits Critical Damping - Motion stabilizes quickly - System returns to equilibrium smoothly High Drive - Complex motion develops - Phase space suggests early chaos","title":"5. Simulation Outcomes"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-summary-and-future-work","text":"This experiment demonstrates how driven damped pendulums can show both stability and complexity, depending on parameters. Possible extensions: - Generate bifurcation diagrams for varying \\(\\omega\\) - Add nonlinear damping - Analyze long-term chaos with Poincar\u00e9 maps These tools help bridge theory with systems seen in engineering, nature, and modern physics.","title":"6. Summary and Future Work"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Gravity Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental relationship enables us to determine planetary motions and understand gravitational interactions on both local and cosmic scales. Derivation of Kepler's Third Law Consider a satellite or planet of mass \\(m\\) orbiting a much larger central body of mass \\(M\\) in a circular orbit. The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\(m\\) and simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) is the time it takes to complete one full orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) into the expression: \\[ T = 2 \\pi r \\sqrt{\\frac{1}{G M}} \\cdot \\sqrt{r} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This is the classical form of Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\] Verification Using Planetary Data We use data from the inner planets of the solar system: Mercury, Venus, Earth, and Mars. import matplotlib.pyplot as plt import numpy as np # Constants AU = 1.496e11 # Astronomical Unit in meters G = 6.67430e-11 M_sun = 1.989e30 # Orbital radii in AU and converted to meters radii_au = np.array([0.39, 0.72, 1.00, 1.52]) radii_m = radii_au * AU # Orbital periods in Earth days converted to seconds periods_days = np.array([88, 225, 365.25, 687]) periods_sec = periods_days * 24 * 3600 # Compute T^2 and r^3 T_squared = periods_sec ** 2 r_cubed = radii_m ** 3 # Plot plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o-', label='Planets') plt.xlabel('$r^3$ (m$^3$)') plt.ylabel('$T^2$ (s$^2$)') plt.title(\\\"Kepler's Third Law: $T^2$ vs $r^3$\\\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() This plot should display a linear relationship, confirming the dependence: \\[ T^2 \\propto r^3 \\] Calculating the Mass of the Sun From the rearranged form of Kepler's Third Law: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Using Earth's orbital parameters: \\(r = 1.496 \\times 10^{11} \\ \\text{m}\\) \\(T = 365.25 \\ \\text{days} = 3.156 \\times 10^7 \\ \\text{s}\\) Plug in values: \\[ M = \\frac{4 \\pi^2 (1.496 \\times 10^{11})^3}{6.67430 \\times 10^{-11} \\cdot (3.156 \\times 10^7)^2} \\approx 1.989 \\times 10^{30} \\ \\text{kg} \\] This result matches the known mass of the Sun. Extension to Elliptical Orbits Kepler\u2019s Third Law applies to elliptical orbits as well, where \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\] Summary Derived \\(T^2 = \\frac{4 \\pi^2 r^3}{G M}\\) Verified \\(T^2 \\propto r^3\\) using Solar System data Estimated the mass of the Sun Generalized to elliptical orbits Colab Link Colab - Gravity Problem 1 Simulation","title":"Gravity Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-problem-1","text":"","title":"Gravity Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental relationship enables us to determine planetary motions and understand gravitational interactions on both local and cosmic scales.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"Consider a satellite or planet of mass \\(m\\) orbiting a much larger central body of mass \\(M\\) in a circular orbit. The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\(m\\) and simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) is the time it takes to complete one full orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) into the expression: \\[ T = 2 \\pi r \\sqrt{\\frac{1}{G M}} \\cdot \\sqrt{r} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This is the classical form of Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\]","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verification-using-planetary-data","text":"We use data from the inner planets of the solar system: Mercury, Venus, Earth, and Mars. import matplotlib.pyplot as plt import numpy as np # Constants AU = 1.496e11 # Astronomical Unit in meters G = 6.67430e-11 M_sun = 1.989e30 # Orbital radii in AU and converted to meters radii_au = np.array([0.39, 0.72, 1.00, 1.52]) radii_m = radii_au * AU # Orbital periods in Earth days converted to seconds periods_days = np.array([88, 225, 365.25, 687]) periods_sec = periods_days * 24 * 3600 # Compute T^2 and r^3 T_squared = periods_sec ** 2 r_cubed = radii_m ** 3 # Plot plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o-', label='Planets') plt.xlabel('$r^3$ (m$^3$)') plt.ylabel('$T^2$ (s$^2$)') plt.title(\\\"Kepler's Third Law: $T^2$ vs $r^3$\\\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() This plot should display a linear relationship, confirming the dependence: \\[ T^2 \\propto r^3 \\]","title":"Verification Using Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-the-mass-of-the-sun","text":"From the rearranged form of Kepler's Third Law: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Using Earth's orbital parameters: \\(r = 1.496 \\times 10^{11} \\ \\text{m}\\) \\(T = 365.25 \\ \\text{days} = 3.156 \\times 10^7 \\ \\text{s}\\) Plug in values: \\[ M = \\frac{4 \\pi^2 (1.496 \\times 10^{11})^3}{6.67430 \\times 10^{-11} \\cdot (3.156 \\times 10^7)^2} \\approx 1.989 \\times 10^{30} \\ \\text{kg} \\] This result matches the known mass of the Sun.","title":"Calculating the Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law applies to elliptical orbits as well, where \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\]","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"Derived \\(T^2 = \\frac{4 \\pi^2 r^3}{G M}\\) Verified \\(T^2 \\propto r^3\\) using Solar System data Estimated the mass of the Sun Generalized to elliptical orbits","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#colab-link","text":"Colab - Gravity Problem 1 Simulation","title":"Colab Link"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Gravity Problem 2 Escape Velocities and Cosmic Velocities Motivation Understanding escape and cosmic velocities is essential in space exploration. These velocities determine the energy required to reach orbit, escape a planet\u2019s gravity, or leave an entire planetary system. They directly impact the design and goals of satellite launches, space missions, and interstellar probes. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is the orbital speed required to maintain a circular orbit near the surface of a planet: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\(G\\) = Gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg\u00b7s\u00b2) - \\(M\\) = Mass of the planet - \\(r\\) = Radius of the planet Second Cosmic Velocity ( \\(v_2\\) ) The second cosmic velocity is the escape velocity required to completely overcome the gravitational pull of a planet: \\[ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} \\] Third Cosmic Velocity ( \\(v_3\\) ) The third cosmic velocity is the minimum speed required to escape the gravity of a planetary system : \\[ v_3 = \\sqrt{v_2^2 + v_{sun}^2} \\] Where \\(v_{sun}\\) is Earth\u2019s orbital velocity around the Sun. Derivations 1. First Cosmic Velocity: From Newton\u2019s law of gravitation and centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v = \\sqrt{\\frac{G M}{r}} \\] 2. Second Cosmic Velocity: From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{G M m}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2 G M}{r}} \\] 3. Third Cosmic Velocity: \\[ v_3 = \\sqrt{v_{\\text{escape}}^2 + v_E^2} \\] Where \\(v_E \\approx 29.78\\) km/s is Earth\u2019s orbital velocity around the Sun. Calculations for Earth, Mars, and Jupiter import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.3895e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } results = {} for name, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 results[name] = {\"v1\": v1, \"v2\": v2} v_sun = 29.78e3 v2_earth = results[\"Earth\"][\"v2\"] v3 = np.sqrt(v2_earth**2 + v_sun**2) results[\"Earth\"][\"v3\"] = v3 for name, vels in results.items(): print(f\"{name}:\") for key, val in vels.items(): print(f\" {key}: {val/1000:.2f} km/s\") Earth: v1: 7.91 km/s v2: 11.19 km/s v3: 31.81 km/s Mars: v1: 3.55 km/s v2: 5.03 km/s Jupiter: v1: 42.57 km/s v2: 60.20 km/s import numpy as np import matplotlib.pyplot as plt # Cosmic velocity data (from previous calculations) results = { \"Earth\": {\"v1\": 7910, \"v2\": 11180, \"v3\": 42150}, \"Mars\": {\"v1\": 3550, \"v2\": 5020}, \"Jupiter\": {\"v1\": 42040, \"v2\": 59450} } labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Visualization of Velocities labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Trajectory Simulation: Gravitational Escape Behavior This plot shows the result of simulating multiple payloads launched from 800 km altitude with varying initial speeds (5 km/s to 13 km/s). It visually demonstrates: Sub-orbital fall back Closed elliptical orbits Parabolic trajectory (near escape) Open hyperbolic escape paths Space Exploration Relevance \\(v_1\\) : Low Earth orbit missions (e.g., satellites, ISS) \\(v_2\\) : Moon missions, Mars rovers, interplanetary probes \\(v_3\\) : Voyager missions, future interstellar missions Summary Derived \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Derived \\(v_2 = \\sqrt{2 G M / r}\\) from energy conservation Defined and visualized \\(v_3\\) from planetary system escape Compared Earth, Mars, Jupiter using bar chart Verified with realistic trajectory graph from 800 km altitude Related each velocity to mission types (LEO, interplanetary, interstellar) Colab Link Colab - Gravity Problem 2 Simulation (https://colab.research.google.com/drive/1jfB5XwMR-niVb6iwQM4RxY5tDNKTG0mm?usp=sharing)","title":"Gravity Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravity-problem-2","text":"","title":"Gravity Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding escape and cosmic velocities is essential in space exploration. These velocities determine the energy required to reach orbit, escape a planet\u2019s gravity, or leave an entire planetary system. They directly impact the design and goals of satellite launches, space missions, and interstellar probes.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The first cosmic velocity is the orbital speed required to maintain a circular orbit near the surface of a planet: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\(G\\) = Gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg\u00b7s\u00b2) - \\(M\\) = Mass of the planet - \\(r\\) = Radius of the planet","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The second cosmic velocity is the escape velocity required to completely overcome the gravitational pull of a planet: \\[ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} \\]","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"The third cosmic velocity is the minimum speed required to escape the gravity of a planetary system : \\[ v_3 = \\sqrt{v_2^2 + v_{sun}^2} \\] Where \\(v_{sun}\\) is Earth\u2019s orbital velocity around the Sun.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivations","text":"","title":"Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity","text":"From Newton\u2019s law of gravitation and centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v = \\sqrt{\\frac{G M}{r}} \\]","title":"1. First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity","text":"From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{G M m}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2 G M}{r}} \\]","title":"2. Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"\\[ v_3 = \\sqrt{v_{\\text{escape}}^2 + v_E^2} \\] Where \\(v_E \\approx 29.78\\) km/s is Earth\u2019s orbital velocity around the Sun.","title":"3. Third Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-earth-mars-and-jupiter","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.3895e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } results = {} for name, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 results[name] = {\"v1\": v1, \"v2\": v2} v_sun = 29.78e3 v2_earth = results[\"Earth\"][\"v2\"] v3 = np.sqrt(v2_earth**2 + v_sun**2) results[\"Earth\"][\"v3\"] = v3 for name, vels in results.items(): print(f\"{name}:\") for key, val in vels.items(): print(f\" {key}: {val/1000:.2f} km/s\") Earth: v1: 7.91 km/s v2: 11.19 km/s v3: 31.81 km/s Mars: v1: 3.55 km/s v2: 5.03 km/s Jupiter: v1: 42.57 km/s v2: 60.20 km/s import numpy as np import matplotlib.pyplot as plt # Cosmic velocity data (from previous calculations) results = { \"Earth\": {\"v1\": 7910, \"v2\": 11180, \"v3\": 42150}, \"Mars\": {\"v1\": 3550, \"v2\": 5020}, \"Jupiter\": {\"v1\": 42040, \"v2\": 59450} } labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Calculations for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization-of-velocities","text":"labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Visualization of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#trajectory-simulation-gravitational-escape-behavior","text":"This plot shows the result of simulating multiple payloads launched from 800 km altitude with varying initial speeds (5 km/s to 13 km/s). It visually demonstrates: Sub-orbital fall back Closed elliptical orbits Parabolic trajectory (near escape) Open hyperbolic escape paths","title":"Trajectory Simulation: Gravitational Escape Behavior"},{"location":"1%20Physics/2%20Gravity/Problem_2/#space-exploration-relevance","text":"\\(v_1\\) : Low Earth orbit missions (e.g., satellites, ISS) \\(v_2\\) : Moon missions, Mars rovers, interplanetary probes \\(v_3\\) : Voyager missions, future interstellar missions","title":"Space Exploration Relevance"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"Derived \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Derived \\(v_2 = \\sqrt{2 G M / r}\\) from energy conservation Defined and visualized \\(v_3\\) from planetary system escape Compared Earth, Mars, Jupiter using bar chart Verified with realistic trajectory graph from 800 km altitude Related each velocity to mission types (LEO, interplanetary, interstellar)","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab-link","text":"Colab - Gravity Problem 2 Simulation (https://colab.research.google.com/drive/1jfB5XwMR-niVb6iwQM4RxY5tDNKTG0mm?usp=sharing)","title":"Colab Link"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation The trajectory of an object released from a rocket near Earth depends significantly on initial conditions such as position, altitude, and velocity. This problem integrates orbital mechanics and numerical analysis, essential for real-world applications in satellite deployment, orbital insertion, reentry strategies, and space exploration. Types of Trajectories When a payload is released near Earth, its trajectory may take one of three forms: Elliptical Trajectory: Bound orbit around Earth. Parabolic Trajectory: Exactly at escape velocity, theoretically escaping Earth\u2019s gravitational influence. Hyperbolic Trajectory: Exceeding escape velocity, permanently escaping Earth\u2019s gravitational pull. The type of trajectory depends primarily on the initial velocity relative to Earth's gravitational pull. Mathematical Analysis Using Newton\u2019s Law of Universal Gravitation: Where: \\(G\\) is gravitational constant \\(M\\) is mass of Earth \\(m\\) is payload mass (cancels out in trajectory calculations) \\(r\\) is distance from Earth\u2019s center Energy Considerations: Total mechanical energy determines the trajectory type: Elliptical: \\(E < 0\\) Parabolic: \\(E = 0\\) Hyperbolic: \\(E > 0\\) Numerical Simulation (Python) Below is a Python script to numerically simulate and visualize payload trajectories: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 Equations of motion def equations(t, y): r = np.sqrt(y[0] 2 + y[1] 2) ax = -G * M * y[0] / r 3 ay = -G * M * y[1] / r 3 return [y[2], y[3], ax, ay] Initial conditions: altitude (400km) and varying velocities altitude = 400e3 v_initial = np.sqrt(G*M/(R_earth+altitude)) # Circular orbital speed Initial conditions for elliptical, parabolic, hyperbolic trajectories initial_conditions = [ (0, R_earth + altitude, 0.8 * v_initial, 0), # Elliptical (0, R_earth + altitude, v_initial np.sqrt(2), 0), # Parabolic (0, R_earth + altitude, 1.2 * v_initial np.sqrt(2), 0) # Hyperbolic ] labels = ['Elliptical', 'Parabolic', 'Hyperbolic'] plt.figure(figsize=(10,10)) for y0, label in zip(initial_conditions, labels): sol = solve_ivp(equations, [0, 8000], y0, max_step=10) plt.plot(sol.y[0]/1e6, sol.y[1]/1e6, label=label) Earth for visualization earth = plt.Circle((0, 0), R_earth/1e6, color='blue', alpha=0.3) plt.gca().add_artist(earth) plt.xlabel('X Position (1000 km)') plt.ylabel('Y Position (1000 km)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show() Real-world Applications Orbital insertion: Payload velocity adjusted precisely for stable elliptical orbits. Satellite deployment: Payloads released at calculated velocities to achieve desired trajectories. Reentry: Adjusting velocities for payloads to safely reenter Earth\u2019s atmosphere. Interplanetary exploration: Hyperbolic trajectories employed to leave Earth's gravitational influence for missions to other planets. Conclusion Understanding and accurately calculating payload trajectories near Earth are vital in space missions. Numerical methods and simulations are essential tools for predicting and visualizing these trajectories, supporting successful mission outcomes.","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"The trajectory of an object released from a rocket near Earth depends significantly on initial conditions such as position, altitude, and velocity. This problem integrates orbital mechanics and numerical analysis, essential for real-world applications in satellite deployment, orbital insertion, reentry strategies, and space exploration.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"When a payload is released near Earth, its trajectory may take one of three forms: Elliptical Trajectory: Bound orbit around Earth. Parabolic Trajectory: Exactly at escape velocity, theoretically escaping Earth\u2019s gravitational influence. Hyperbolic Trajectory: Exceeding escape velocity, permanently escaping Earth\u2019s gravitational pull. The type of trajectory depends primarily on the initial velocity relative to Earth's gravitational pull. Mathematical Analysis Using Newton\u2019s Law of Universal Gravitation: Where: \\(G\\) is gravitational constant \\(M\\) is mass of Earth \\(m\\) is payload mass (cancels out in trajectory calculations) \\(r\\) is distance from Earth\u2019s center Energy Considerations: Total mechanical energy determines the trajectory type: Elliptical: \\(E < 0\\) Parabolic: \\(E = 0\\) Hyperbolic: \\(E > 0\\) Numerical Simulation (Python) Below is a Python script to numerically simulate and visualize payload trajectories: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"def equations(t, y): r = np.sqrt(y[0] 2 + y[1] 2) ax = -G * M * y[0] / r 3 ay = -G * M * y[1] / r 3 return [y[2], y[3], ax, ay]","title":"Equations of motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-altitude-400km-and-varying-velocities","text":"altitude = 400e3 v_initial = np.sqrt(G*M/(R_earth+altitude)) # Circular orbital speed","title":"Initial conditions: altitude (400km) and varying velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-for-elliptical-parabolic-hyperbolic-trajectories","text":"initial_conditions = [ (0, R_earth + altitude, 0.8 * v_initial, 0), # Elliptical (0, R_earth + altitude, v_initial np.sqrt(2), 0), # Parabolic (0, R_earth + altitude, 1.2 * v_initial np.sqrt(2), 0) # Hyperbolic ] labels = ['Elliptical', 'Parabolic', 'Hyperbolic'] plt.figure(figsize=(10,10)) for y0, label in zip(initial_conditions, labels): sol = solve_ivp(equations, [0, 8000], y0, max_step=10) plt.plot(sol.y[0]/1e6, sol.y[1]/1e6, label=label)","title":"Initial conditions for elliptical, parabolic, hyperbolic trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#earth-for-visualization","text":"earth = plt.Circle((0, 0), R_earth/1e6, color='blue', alpha=0.3) plt.gca().add_artist(earth) plt.xlabel('X Position (1000 km)') plt.ylabel('Y Position (1000 km)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show()","title":"Earth for visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Orbital insertion: Payload velocity adjusted precisely for stable elliptical orbits. Satellite deployment: Payloads released at calculated velocities to achieve desired trajectories. Reentry: Adjusting velocities for payloads to safely reenter Earth\u2019s atmosphere. Interplanetary exploration: Hyperbolic trajectories employed to leave Earth's gravitational influence for missions to other planets.","title":"Real-world Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Understanding and accurately calculating payload trajectories near Earth are vital in space missions. Numerical methods and simulations are essential tools for predicting and visualizing these trajectories, supporting successful mission outcomes.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}