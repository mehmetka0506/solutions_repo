{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, though seemingly simple, presents a deep and rich structure when examined thoroughly. By studying how the range of a projectile depends on the launch angle, we reveal fundamental principles of kinematics and dynamics. Variables like initial velocity, gravitational acceleration, and launch height provide a broad variety of solutions, applicable to real-world situations such as sports, engineering, and space science. Theoretical Foundation Starting from the basic laws of motion, we can derive the projectile equations. Assume no air resistance and flat terrain. Let: \\(v_0\\) = Initial velocity \\(\\theta\\) = Angle of projection \\(g\\) = Gravitational acceleration The equations of motion are: $$ \\frac{d^2x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) $$ \\[ \\frac{d^2y}{dt^2} = -g \\quad \\Rightarrow \\quad \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\] Integrating these: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] Time of Flight Setting \\(y = 0\\) at landing: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2}gT^2 \\] Solving for T \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range Horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum Height The maximum vertical position: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] Observations Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , that is, \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effects of parameters \\(v_0\\) : Range increases quadratically with initial velocity. \\(g\\) : Range decreases inversely with gravitational acceleration. Launch height: Would modify the symmetry and the optimal angle if included. Practical Applications Sports: Finding the best launch angles for throws, shots, or kicks. Engineering: Ballistics calculations. Astrophysics: Launching satellites or projectiles from planetary surfaces. Including air resistance, wind, or launching from non-level terrain are real-world complications addressed with numerical methods. Implementation Below are Python scripts simulating projectile motion under the given scenarios. import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 1: 45\u00b0 angle, different velocities (30, 40, 50 m/s) import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 2: 50 m/s, different angles (15\u00b0, 45\u00b0, 75\u00b0) angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representations In the first plot, as initial velocity increases, range increases significantly. angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() In the second plot, \\(45^\\circ\\) provides the maximum range, while \\(15^\\circ\\) and \\(75^\\circ\\) give the same (shorter) range. Limitations and Extensions Limitations No air resistance considered. Flat launch and landing height assumed. Extensions Include air resistance: drag force proportional to velocity. Launch from or land on elevated platforms. Add wind effects. Summary Analyzing projectile motion illustrates fundamental physics while also introducing opportunities for deeper exploration using computational methods. Studying range as a function of launch angle helps us understand both idealized and real-world trajectories. Colab Link Colab - Problem 1 Simulation","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, though seemingly simple, presents a deep and rich structure when examined thoroughly. By studying how the range of a projectile depends on the launch angle, we reveal fundamental principles of kinematics and dynamics. Variables like initial velocity, gravitational acceleration, and launch height provide a broad variety of solutions, applicable to real-world situations such as sports, engineering, and space science.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"Starting from the basic laws of motion, we can derive the projectile equations. Assume no air resistance and flat terrain. Let: \\(v_0\\) = Initial velocity \\(\\theta\\) = Angle of projection \\(g\\) = Gravitational acceleration The equations of motion are: $$ \\frac{d^2x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) $$ \\[ \\frac{d^2y}{dt^2} = -g \\quad \\Rightarrow \\quad \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\] Integrating these: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Setting \\(y = 0\\) at landing: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2}gT^2 \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solving-for-t","text":"\\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Solving for T"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"Horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#maximum-height","text":"The maximum vertical position: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , that is, \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effects of parameters \\(v_0\\) : Range increases quadratically with initial velocity. \\(g\\) : Range decreases inversely with gravitational acceleration. Launch height: Would modify the symmetry and the optimal angle if included. Practical Applications Sports: Finding the best launch angles for throws, shots, or kicks. Engineering: Ballistics calculations. Astrophysics: Launching satellites or projectiles from planetary surfaces. Including air resistance, wind, or launching from non-level terrain are real-world complications addressed with numerical methods.","title":"Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"Below are Python scripts simulating projectile motion under the given scenarios. import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 1: 45\u00b0 angle, different velocities (30, 40, 50 m/s) import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 2: 50 m/s, different angles (15\u00b0, 45\u00b0, 75\u00b0) angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representations In the first plot, as initial velocity increases, range increases significantly. angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() In the second plot, \\(45^\\circ\\) provides the maximum range, while \\(15^\\circ\\) and \\(75^\\circ\\) give the same (shorter) range.","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"Limitations No air resistance considered. Flat launch and landing height assumed. Extensions Include air resistance: drag force proportional to velocity. Launch from or land on elevated platforms. Add wind effects.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Analyzing projectile motion illustrates fundamental physics while also introducing opportunities for deeper exploration using computational methods. Studying range as a function of launch angle helps us understand both idealized and real-world trajectories.","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab-link","text":"Colab - Problem 1 Simulation","title":"Colab Link"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Dynamics of a Forced Damped Pendulum: A Computational Exploration Motivation The forced damped pendulum is a key system in nonlinear dynamics. When damping and external periodic forces act on a pendulum, its behavior ranges from predictable oscillations to complex and chaotic motion. This diversity reflects many real-world systems \u2014 from electronics to biomechanics. By tuning parameters like the damping factor and the strength and frequency of the driving force, we observe phenomena such as resonance, quasiperiodicity, and transitions to chaos. These insights are fundamental in understanding oscillatory systems in engineering, physics, and nature. 1. Mathematical Framework Differential Equation The system is modeled by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement - \\(b\\) : damping coefficient - \\(g\\) : gravitational acceleration - \\(L\\) : length of pendulum - \\(A\\) : external driving amplitude - \\(\\omega\\) : angular frequency of the driving force Linear Approximation (Small Angle) For small angular displacements: \\[ \\sin\\theta \\approx \\theta \\] Reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This linear form simplifies simulation and helps analyze regular behavior before chaos emerges. 2. Parameter-Based Behavior Analysis We analyze system behavior by varying: Damping coefficient \\(b\\) Driving amplitude \\(A\\) Driving frequency \\(\\omega\\) This helps reveal: - Transition from underdamped to overdamped behavior - Resonance and amplification - Onset of chaotic regimes 3. Real-World Relevance This model describes: - Suspension systems in vehicles - Oscillating electrical circuits (e.g., RLC) - Structures under periodic stress - Biological movement patterns (gait dynamics) 4. Python Modeling Below is a simulation using solve_ivp from scipy.integrate to model pendulum behavior for different conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def dynamics(t, y, b, g, L, A, omega): theta, omega_ = y return [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] # Setup y0 = [0.15, 0.0] t_range = (0, 60) t_eval = np.linspace(*t_range, 1500) cases = [ {\"label\": \"Light Damping\", \"b\": 0.1, \"A\": 0.8, \"omega\": 1.0, \"color\": \"royalblue\"}, {\"label\": \"Critical Damping\", \"b\": 0.6, \"A\": 0.8, \"omega\": 1.0, \"color\": \"firebrick\"}, {\"label\": \"High Drive\", \"b\": 0.3, \"A\": 1.8, \"omega\": 3.0, \"color\": \"darkgreen\"}, ] g = 9.8 L = 1.0 fig, axes = plt.subplots(len(cases), 2, figsize=(12, 11)) for i, c in enumerate(cases): sol = solve_ivp( dynamics, t_range, y0, args=(c[\"b\"], g, L, c[\"A\"], c[\"omega\"]), t_eval=t_eval ) theta, omega_ = sol.y axes[i, 0].plot(sol.t, theta, color=c[\"color\"]) axes[i, 0].set_title(f'{c[\"label\"]} - \u03b8(t)') axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"\u03b8 (rad)\") axes[i, 0].grid() axes[i, 1].plot(theta, omega_, color=c[\"color\"]) axes[i, 1].set_title(f'{c[\"label\"]} - Phase Diagram') axes[i, 1].set_xlabel(\"\u03b8 (rad)\") axes[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axes[i, 1].grid() plt.tight_layout() plt.show() <<<<<<< HEAD ======= - 5. Simulation Outcomes Light Damping - Oscillations persist - Phase plot shows large elliptical orbits Critical Damping - Motion stabilizes quickly - System returns to equilibrium smoothly High Drive - Complex motion develops - Phase space suggests early chaos 6. Summary and Future Work This experiment demonstrates how driven damped pendulums can show both stability and complexity, depending on parameters. Possible extensions: - Generate bifurcation diagrams for varying \\(\\omega\\) - Add nonlinear damping - Analyze long-term chaos with Poincar\u00e9 maps These tools help bridge theory with systems seen in engineering, nature, and modern physics.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#dynamics-of-a-forced-damped-pendulum-a-computational-exploration","text":"","title":"Dynamics of a Forced Damped Pendulum: A Computational Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a key system in nonlinear dynamics. When damping and external periodic forces act on a pendulum, its behavior ranges from predictable oscillations to complex and chaotic motion. This diversity reflects many real-world systems \u2014 from electronics to biomechanics. By tuning parameters like the damping factor and the strength and frequency of the driving force, we observe phenomena such as resonance, quasiperiodicity, and transitions to chaos. These insights are fundamental in understanding oscillatory systems in engineering, physics, and nature.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-mathematical-framework","text":"","title":"1. Mathematical Framework"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The system is modeled by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement - \\(b\\) : damping coefficient - \\(g\\) : gravitational acceleration - \\(L\\) : length of pendulum - \\(A\\) : external driving amplitude - \\(\\omega\\) : angular frequency of the driving force","title":"Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#linear-approximation-small-angle","text":"For small angular displacements: \\[ \\sin\\theta \\approx \\theta \\] Reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This linear form simplifies simulation and helps analyze regular behavior before chaos emerges.","title":"Linear Approximation (Small Angle)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-parameter-based-behavior-analysis","text":"We analyze system behavior by varying: Damping coefficient \\(b\\) Driving amplitude \\(A\\) Driving frequency \\(\\omega\\) This helps reveal: - Transition from underdamped to overdamped behavior - Resonance and amplification - Onset of chaotic regimes","title":"2. Parameter-Based Behavior Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-relevance","text":"This model describes: - Suspension systems in vehicles - Oscillating electrical circuits (e.g., RLC) - Structures under periodic stress - Biological movement patterns (gait dynamics)","title":"3. Real-World Relevance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-modeling","text":"Below is a simulation using solve_ivp from scipy.integrate to model pendulum behavior for different conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def dynamics(t, y, b, g, L, A, omega): theta, omega_ = y return [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] # Setup y0 = [0.15, 0.0] t_range = (0, 60) t_eval = np.linspace(*t_range, 1500) cases = [ {\"label\": \"Light Damping\", \"b\": 0.1, \"A\": 0.8, \"omega\": 1.0, \"color\": \"royalblue\"}, {\"label\": \"Critical Damping\", \"b\": 0.6, \"A\": 0.8, \"omega\": 1.0, \"color\": \"firebrick\"}, {\"label\": \"High Drive\", \"b\": 0.3, \"A\": 1.8, \"omega\": 3.0, \"color\": \"darkgreen\"}, ] g = 9.8 L = 1.0 fig, axes = plt.subplots(len(cases), 2, figsize=(12, 11)) for i, c in enumerate(cases): sol = solve_ivp( dynamics, t_range, y0, args=(c[\"b\"], g, L, c[\"A\"], c[\"omega\"]), t_eval=t_eval ) theta, omega_ = sol.y axes[i, 0].plot(sol.t, theta, color=c[\"color\"]) axes[i, 0].set_title(f'{c[\"label\"]} - \u03b8(t)') axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"\u03b8 (rad)\") axes[i, 0].grid() axes[i, 1].plot(theta, omega_, color=c[\"color\"]) axes[i, 1].set_title(f'{c[\"label\"]} - Phase Diagram') axes[i, 1].set_xlabel(\"\u03b8 (rad)\") axes[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axes[i, 1].grid() plt.tight_layout() plt.show() <<<<<<< HEAD ======= -","title":"4. Python Modeling"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-simulation-outcomes","text":"Light Damping - Oscillations persist - Phase plot shows large elliptical orbits Critical Damping - Motion stabilizes quickly - System returns to equilibrium smoothly High Drive - Complex motion develops - Phase space suggests early chaos","title":"5. Simulation Outcomes"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-summary-and-future-work","text":"This experiment demonstrates how driven damped pendulums can show both stability and complexity, depending on parameters. Possible extensions: - Generate bifurcation diagrams for varying \\(\\omega\\) - Add nonlinear damping - Analyze long-term chaos with Poincar\u00e9 maps These tools help bridge theory with systems seen in engineering, nature, and modern physics.","title":"6. Summary and Future Work"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Gravity Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental relationship enables us to determine planetary motions and understand gravitational interactions on both local and cosmic scales. Derivation of Kepler's Third Law Consider a satellite or planet of mass \\(m\\) orbiting a much larger central body of mass \\(M\\) in a circular orbit. The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\(m\\) and simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) is the time it takes to complete one full orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) into the expression: \\[ T = 2 \\pi r \\sqrt{\\frac{1}{G M}} \\cdot \\sqrt{r} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This is the classical form of Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\] Verification Using Planetary Data We use data from the inner planets of the solar system: Mercury, Venus, Earth, and Mars. import matplotlib.pyplot as plt import numpy as np AU = 1.496e11 G = 6.67430e-11 M_sun = 1.989e30 planet_names = ['Mercury', 'Venus', 'Earth', 'Mars'] radii_au = np.array([0.39, 0.72, 1.00, 1.52]) radii_m = radii_au * AU periods_days = np.array([88, 225, 365.25, 687]) periods_sec = periods_days * 24 * 3600 T_squared = periods_sec ** 2 r_cubed = radii_m ** 3 # Theoretical Kepler's Third Law line: T^2 = (4\u03c0\u00b2 / GM) * r^3 kepler_constant = (4 * np.pi ** 2) / (G * M_sun) r_range = np.linspace(min(r_cubed), max(r_cubed), 100) T_squared_theoretical = kepler_constant * r_range plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o', label='Planets') plt.plot(r_range, T_squared_theoretical, '-', label=\"Kepler's Law\", linewidth=2) # Label each point for i, name in enumerate(planet_names): plt.text(r_cubed[i] * 1.01, T_squared[i] * 1.01, name) plt.xlabel('$r^3$ (m$^3$)', fontsize=12) plt.ylabel('$T^2$ (s$^2$)', fontsize=12) plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\", fontsize=14) plt.grid(True) plt.legend() plt.tight_layout() plt.show() This plot should display a linear relationship, confirming the dependence: \\[ T^2 \\propto r^3 \\] Calculating the Mass of the Sun From the rearranged form of Kepler's Third Law: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Using Earth's orbital parameters: \\(r = 1.496 \\times 10^{11} \\ \\text{m}\\) \\(T = 365.25 \\ \\text{days} = 3.156 \\times 10^7 \\ \\text{s}\\) Plug in values: \\[ M = \\frac{4 \\pi^2 (1.496 \\times 10^{11})^3}{6.67430 \\times 10^{-11} \\cdot (3.156 \\times 10^7)^2} \\approx 1.989 \\times 10^{30} \\ \\text{kg} \\] This result matches the known mass of the Sun. Extension to Elliptical Orbits Kepler\u2019s Third Law applies to elliptical orbits as well, where \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\] Summary Derived \\(T^2 = \\frac{4 \\pi^2 r^3}{G M}\\) Verified \\(T^2 \\propto r^3\\) using Solar System data Estimated the mass of the Sun Generalized to elliptical orbits Colab Link Colab - Gravity Problem 1 Simulation","title":"Gravity Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-problem-1","text":"","title":"Gravity Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental relationship enables us to determine planetary motions and understand gravitational interactions on both local and cosmic scales.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"Consider a satellite or planet of mass \\(m\\) orbiting a much larger central body of mass \\(M\\) in a circular orbit. The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\(m\\) and simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) is the time it takes to complete one full orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) into the expression: \\[ T = 2 \\pi r \\sqrt{\\frac{1}{G M}} \\cdot \\sqrt{r} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This is the classical form of Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\]","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verification-using-planetary-data","text":"We use data from the inner planets of the solar system: Mercury, Venus, Earth, and Mars. import matplotlib.pyplot as plt import numpy as np AU = 1.496e11 G = 6.67430e-11 M_sun = 1.989e30 planet_names = ['Mercury', 'Venus', 'Earth', 'Mars'] radii_au = np.array([0.39, 0.72, 1.00, 1.52]) radii_m = radii_au * AU periods_days = np.array([88, 225, 365.25, 687]) periods_sec = periods_days * 24 * 3600 T_squared = periods_sec ** 2 r_cubed = radii_m ** 3 # Theoretical Kepler's Third Law line: T^2 = (4\u03c0\u00b2 / GM) * r^3 kepler_constant = (4 * np.pi ** 2) / (G * M_sun) r_range = np.linspace(min(r_cubed), max(r_cubed), 100) T_squared_theoretical = kepler_constant * r_range plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o', label='Planets') plt.plot(r_range, T_squared_theoretical, '-', label=\"Kepler's Law\", linewidth=2) # Label each point for i, name in enumerate(planet_names): plt.text(r_cubed[i] * 1.01, T_squared[i] * 1.01, name) plt.xlabel('$r^3$ (m$^3$)', fontsize=12) plt.ylabel('$T^2$ (s$^2$)', fontsize=12) plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\", fontsize=14) plt.grid(True) plt.legend() plt.tight_layout() plt.show() This plot should display a linear relationship, confirming the dependence: \\[ T^2 \\propto r^3 \\]","title":"Verification Using Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-the-mass-of-the-sun","text":"From the rearranged form of Kepler's Third Law: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Using Earth's orbital parameters: \\(r = 1.496 \\times 10^{11} \\ \\text{m}\\) \\(T = 365.25 \\ \\text{days} = 3.156 \\times 10^7 \\ \\text{s}\\) Plug in values: \\[ M = \\frac{4 \\pi^2 (1.496 \\times 10^{11})^3}{6.67430 \\times 10^{-11} \\cdot (3.156 \\times 10^7)^2} \\approx 1.989 \\times 10^{30} \\ \\text{kg} \\] This result matches the known mass of the Sun.","title":"Calculating the Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law applies to elliptical orbits as well, where \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\]","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"Derived \\(T^2 = \\frac{4 \\pi^2 r^3}{G M}\\) Verified \\(T^2 \\propto r^3\\) using Solar System data Estimated the mass of the Sun Generalized to elliptical orbits","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#colab-link","text":"Colab - Gravity Problem 1 Simulation","title":"Colab Link"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Gravity Problem 2 Escape Velocities and Cosmic Velocities Motivation Understanding escape and cosmic velocities is essential in space exploration. These velocities determine the energy required to reach orbit, escape a planet\u2019s gravity, or leave an entire planetary system. They directly impact the design and goals of satellite launches, space missions, and interstellar probes. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is the orbital speed required to maintain a circular orbit near the surface of a planet: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\(G\\) = Gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg\u00b7s\u00b2) - \\(M\\) = Mass of the planet - \\(r\\) = Radius of the planet Second Cosmic Velocity ( \\(v_2\\) ) The second cosmic velocity is the escape velocity required to completely overcome the gravitational pull of a planet: \\[ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} \\] Third Cosmic Velocity ( \\(v_3\\) ) The third cosmic velocity is the minimum speed required to escape the gravity of a planetary system : \\[ v_3 = \\sqrt{v_2^2 + v_{sun}^2} \\] Where \\(v_{sun}\\) is Earth\u2019s orbital velocity around the Sun. Derivations 1. First Cosmic Velocity: From Newton\u2019s law of gravitation and centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v = \\sqrt{\\frac{G M}{r}} \\] 2. Second Cosmic Velocity: From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{G M m}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2 G M}{r}} \\] 3. Third Cosmic Velocity: \\[ v_3 = \\sqrt{v_{\\text{escape}}^2 + v_E^2} \\] Where \\(v_E \\approx 29.78\\) km/s is Earth\u2019s orbital velocity around the Sun. Calculations for Earth, Mars, and Jupiter import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.3895e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } results = {} for name, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 results[name] = {\"v1\": v1, \"v2\": v2} v_sun = 29.78e3 v2_earth = results[\"Earth\"][\"v2\"] v3 = np.sqrt(v2_earth**2 + v_sun**2) results[\"Earth\"][\"v3\"] = v3 for name, vels in results.items(): print(f\"{name}:\") for key, val in vels.items(): print(f\" {key}: {val/1000:.2f} km/s\") Earth: v1: 7.91 km/s v2: 11.19 km/s v3: 31.81 km/s Mars: v1: 3.55 km/s v2: 5.03 km/s Jupiter: v1: 42.57 km/s v2: 60.20 km/s import numpy as np import matplotlib.pyplot as plt # Cosmic velocity data (from previous calculations) results = { \"Earth\": {\"v1\": 7910, \"v2\": 11180, \"v3\": 42150}, \"Mars\": {\"v1\": 3550, \"v2\": 5020}, \"Jupiter\": {\"v1\": 42040, \"v2\": 59450} } labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Visualization of Velocities labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Trajectory Simulation: Gravitational Escape Behavior This plot shows the result of simulating multiple payloads launched from 800 km altitude with varying initial speeds (5 km/s to 13 km/s). It visually demonstrates: Sub-orbital fall back Closed elliptical orbits Parabolic trajectory (near escape) Open hyperbolic escape paths Space Exploration Relevance \\(v_1\\) : Low Earth orbit missions (e.g., satellites, ISS) \\(v_2\\) : Moon missions, Mars rovers, interplanetary probes \\(v_3\\) : Voyager missions, future interstellar missions Summary Derived \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Derived \\(v_2 = \\sqrt{2 G M / r}\\) from energy conservation Defined and visualized \\(v_3\\) from planetary system escape Compared Earth, Mars, Jupiter using bar chart Verified with realistic trajectory graph from 800 km altitude Related each velocity to mission types (LEO, interplanetary, interstellar) Colab Link Colab - Gravity Problem 2 Simulation (https://colab.research.google.com/drive/1jfB5XwMR-niVb6iwQM4RxY5tDNKTG0mm?usp=sharing)","title":"Gravity Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravity-problem-2","text":"","title":"Gravity Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding escape and cosmic velocities is essential in space exploration. These velocities determine the energy required to reach orbit, escape a planet\u2019s gravity, or leave an entire planetary system. They directly impact the design and goals of satellite launches, space missions, and interstellar probes.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The first cosmic velocity is the orbital speed required to maintain a circular orbit near the surface of a planet: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\(G\\) = Gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg\u00b7s\u00b2) - \\(M\\) = Mass of the planet - \\(r\\) = Radius of the planet","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The second cosmic velocity is the escape velocity required to completely overcome the gravitational pull of a planet: \\[ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} \\]","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"The third cosmic velocity is the minimum speed required to escape the gravity of a planetary system : \\[ v_3 = \\sqrt{v_2^2 + v_{sun}^2} \\] Where \\(v_{sun}\\) is Earth\u2019s orbital velocity around the Sun.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivations","text":"","title":"Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity","text":"From Newton\u2019s law of gravitation and centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v = \\sqrt{\\frac{G M}{r}} \\]","title":"1. First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity","text":"From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{G M m}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2 G M}{r}} \\]","title":"2. Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"\\[ v_3 = \\sqrt{v_{\\text{escape}}^2 + v_E^2} \\] Where \\(v_E \\approx 29.78\\) km/s is Earth\u2019s orbital velocity around the Sun.","title":"3. Third Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-earth-mars-and-jupiter","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.3895e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } results = {} for name, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 results[name] = {\"v1\": v1, \"v2\": v2} v_sun = 29.78e3 v2_earth = results[\"Earth\"][\"v2\"] v3 = np.sqrt(v2_earth**2 + v_sun**2) results[\"Earth\"][\"v3\"] = v3 for name, vels in results.items(): print(f\"{name}:\") for key, val in vels.items(): print(f\" {key}: {val/1000:.2f} km/s\") Earth: v1: 7.91 km/s v2: 11.19 km/s v3: 31.81 km/s Mars: v1: 3.55 km/s v2: 5.03 km/s Jupiter: v1: 42.57 km/s v2: 60.20 km/s import numpy as np import matplotlib.pyplot as plt # Cosmic velocity data (from previous calculations) results = { \"Earth\": {\"v1\": 7910, \"v2\": 11180, \"v3\": 42150}, \"Mars\": {\"v1\": 3550, \"v2\": 5020}, \"Jupiter\": {\"v1\": 42040, \"v2\": 59450} } labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Calculations for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization-of-velocities","text":"labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Visualization of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#trajectory-simulation-gravitational-escape-behavior","text":"This plot shows the result of simulating multiple payloads launched from 800 km altitude with varying initial speeds (5 km/s to 13 km/s). It visually demonstrates: Sub-orbital fall back Closed elliptical orbits Parabolic trajectory (near escape) Open hyperbolic escape paths","title":"Trajectory Simulation: Gravitational Escape Behavior"},{"location":"1%20Physics/2%20Gravity/Problem_2/#space-exploration-relevance","text":"\\(v_1\\) : Low Earth orbit missions (e.g., satellites, ISS) \\(v_2\\) : Moon missions, Mars rovers, interplanetary probes \\(v_3\\) : Voyager missions, future interstellar missions","title":"Space Exploration Relevance"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"Derived \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Derived \\(v_2 = \\sqrt{2 G M / r}\\) from energy conservation Defined and visualized \\(v_3\\) from planetary system escape Compared Earth, Mars, Jupiter using bar chart Verified with realistic trajectory graph from 800 km altitude Related each velocity to mission types (LEO, interplanetary, interstellar)","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab-link","text":"Colab - Gravity Problem 2 Simulation (https://colab.research.google.com/drive/1jfB5XwMR-niVb6iwQM4RxY5tDNKTG0mm?usp=sharing)","title":"Colab Link"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Gravity Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces . This problem combines orbital mechanics and numerical simulations . Understanding these trajectories is vital for: Satellite deployment Orbital insertion Reentry planning Escape missions from Earth Theoretical Background Gravitational force acting on a mass: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\( G = 6.67430 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) (Gravitational constant) - \\( M \\) is the Earth's mass - \\( m \\) is the payload mass - \\( r \\) is the distance from the center of Earth Energy-Based Trajectory Classification: Total mechanical energy: $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} $$ If \\( E < 0 \\) \u2192 Elliptical Orbit If \\( E = 0 \\) \u2192 Parabolic Trajectory If \\( E > 0 \\) \u2192 Hyperbolic Trajectory Simulation Parameters Initial altitude = 800 km above Earth's surface Start point is placed at (0, R + 800e3) \u2192 clearly visible to the right of Earth Initial velocities from 5.0 km/s to 13.0 km/s , with 0.5 km/s increments Python Simulation Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import matplotlib.animation as animation from IPython.display import HTML G = 6.67430e-11 # Evrensel \u00e7ekim sabiti M = 5.972e24 # D\u00fcnya k\u00fctlesi (kg) R_earth = 6.371e6 # D\u00fcnya yar\u0131\u00e7ap\u0131 (m) altitude = 800e3 # Ba\u015flang\u0131\u00e7 y\u00fcksekli\u011fi (800 km) r0 = R_earth + altitude velocities = [5e3, 7.5e3, 11.5e3] # km/s: 5.0, 7.5, 11.5 colors = ['red', 'green', 'blue'] labels = ['5.0 km/s', '7.5 km/s', '11.5 km/s'] trajectories = [] def motion(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] for v in velocities: y0 = [0, r0, v, 0] # pozisyon ve h\u0131z sol = solve_ivp(motion, [0, 7000], y0, max_step=5) trajectories.append((sol.y[0] / 1e6, sol.y[1] / 1e6)) # km cinsinden fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-10, 30) ax.set_ylim(-10, 30) ax.set_xlabel('X (1000 km)') ax.set_ylabel('Y (1000 km)') ax.set_title('Payload Trajectories Animation') ax.grid(True) earth = plt.Circle((0, 0), R_earth / 1e6, color='blue', alpha=0.3) ax.add_patch(earth) lines = [ax.plot([], [], color=c, label=l)[0] for c, l in zip(colors, labels)] points = [ax.plot([], [], 'o', color=c)[0] for c in colors] ax.legend() def init(): for line, point in zip(lines, points): line.set_data([], []) point.set_data([], []) return lines + points def update(frame): for i, (x, y) in enumerate(trajectories): if frame < len(x): lines[i].set_data(x[:frame], y[:frame]) points[i].set_data([x[frame]], [y[frame]]) # Pass as sequences return lines + points ani = animation.FuncAnimation(fig, update, frames=400, init_func=init, blit=True, interval=40) HTML(ani.to_jshtml()) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp G = 6.67430e-11 # Universal gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) R_sun = 6.9634e8 # Radius of the Sun (m) AU = 1.496e11 # 1 Astronomical Unit in meters r0 = AU # Starting position 1 AU from the Sun def motion(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M_sun * x / r**3 ay = -G * M_sun * y_pos / r**3 return [vx, vy, ax, ay] velocities = np.arange(25e3, 52e3, 5e3) # In m/s plt.figure(figsize=(10, 10)) for v in velocities: y0 = [r0, 0, 0, v] # Initial pos at 1 AU on x-axis, velocity in +y direction sol = solve_ivp(motion, [0, 3.154e7], y0, max_step=1000) # 1 year plt.plot(sol.y[0]/AU, sol.y[1]/AU, label=f'{v/1e3:.0f} km/s') sun = plt.Circle((0, 0), R_sun / AU, color='orange', alpha=0.5) plt.gca().add_artist(sun) plt.title(\"Payload Trajectories from 1 AU (Sun-Centered)\") plt.xlabel(\"X Position (AU)\") plt.ylabel(\"Y Position (AU)\") plt.grid(True) plt.axis('equal') plt.legend(title=\"Initial Velocity\") plt.tight_layout() plt.show() Output Plot & Observations This plot clearly shows: 5.0\u20137.0 km/s: Payload crashes back to Earth 7.5\u20138.5 km/s: Elliptical and nearly circular orbits 11.2 km/s+: Escape velocities, resulting in open hyperbolic trajectories D\u00fcnya yar\u0131\u00e7ap\u0131 orant\u0131l\u0131 mavi daire ile \u00e7izildi. Payload ba\u015flama noktas\u0131 800 km yukar\u0131da ve D\u00fcnya'n\u0131n sa\u011f\u0131ndad\u0131r, hocan\u0131n belirtti\u011fi gibi. Real-World Relevance Use Case Velocity Range Outcome LEO Satellite Deployment ~7.5 km/s Circular/Elliptical orbit ISS Missions ~7.66 km/s Stable LEO orbit Lunar / Mars Missions >11.2 km/s Escape trajectory (v\u2082) Reentry Capsule <7.5 km/s Controlled fall or crash Summary Earth drawn to scale on plot Initial position: 800 km above Earth Velocities: 5.0 to 13.0 km/s (in 0.5 km/s steps) Simulation uses Newtonian gravity + numerical integration Graph clearly shows orbital vs escape behavior Trajectories plotted with proper units & legends Colab Link Colab \u2013 Gravity Problem 3 Simulation","title":"Gravity Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravity-problem-3","text":"","title":"Gravity Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces . This problem combines orbital mechanics and numerical simulations . Understanding these trajectories is vital for: Satellite deployment Orbital insertion Reentry planning Escape missions from Earth","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"Gravitational force acting on a mass: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\( G = 6.67430 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) (Gravitational constant) - \\( M \\) is the Earth's mass - \\( m \\) is the payload mass - \\( r \\) is the distance from the center of Earth","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#energy-based-trajectory-classification","text":"Total mechanical energy: $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} $$ If \\( E < 0 \\) \u2192 Elliptical Orbit If \\( E = 0 \\) \u2192 Parabolic Trajectory If \\( E > 0 \\) \u2192 Hyperbolic Trajectory","title":"Energy-Based Trajectory Classification:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"Initial altitude = 800 km above Earth's surface Start point is placed at (0, R + 800e3) \u2192 clearly visible to the right of Earth Initial velocities from 5.0 km/s to 13.0 km/s , with 0.5 km/s increments","title":"Simulation Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import matplotlib.animation as animation from IPython.display import HTML G = 6.67430e-11 # Evrensel \u00e7ekim sabiti M = 5.972e24 # D\u00fcnya k\u00fctlesi (kg) R_earth = 6.371e6 # D\u00fcnya yar\u0131\u00e7ap\u0131 (m) altitude = 800e3 # Ba\u015flang\u0131\u00e7 y\u00fcksekli\u011fi (800 km) r0 = R_earth + altitude velocities = [5e3, 7.5e3, 11.5e3] # km/s: 5.0, 7.5, 11.5 colors = ['red', 'green', 'blue'] labels = ['5.0 km/s', '7.5 km/s', '11.5 km/s'] trajectories = [] def motion(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] for v in velocities: y0 = [0, r0, v, 0] # pozisyon ve h\u0131z sol = solve_ivp(motion, [0, 7000], y0, max_step=5) trajectories.append((sol.y[0] / 1e6, sol.y[1] / 1e6)) # km cinsinden fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-10, 30) ax.set_ylim(-10, 30) ax.set_xlabel('X (1000 km)') ax.set_ylabel('Y (1000 km)') ax.set_title('Payload Trajectories Animation') ax.grid(True) earth = plt.Circle((0, 0), R_earth / 1e6, color='blue', alpha=0.3) ax.add_patch(earth) lines = [ax.plot([], [], color=c, label=l)[0] for c, l in zip(colors, labels)] points = [ax.plot([], [], 'o', color=c)[0] for c in colors] ax.legend() def init(): for line, point in zip(lines, points): line.set_data([], []) point.set_data([], []) return lines + points def update(frame): for i, (x, y) in enumerate(trajectories): if frame < len(x): lines[i].set_data(x[:frame], y[:frame]) points[i].set_data([x[frame]], [y[frame]]) # Pass as sequences return lines + points ani = animation.FuncAnimation(fig, update, frames=400, init_func=init, blit=True, interval=40) HTML(ani.to_jshtml()) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp G = 6.67430e-11 # Universal gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) R_sun = 6.9634e8 # Radius of the Sun (m) AU = 1.496e11 # 1 Astronomical Unit in meters r0 = AU # Starting position 1 AU from the Sun def motion(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M_sun * x / r**3 ay = -G * M_sun * y_pos / r**3 return [vx, vy, ax, ay] velocities = np.arange(25e3, 52e3, 5e3) # In m/s plt.figure(figsize=(10, 10)) for v in velocities: y0 = [r0, 0, 0, v] # Initial pos at 1 AU on x-axis, velocity in +y direction sol = solve_ivp(motion, [0, 3.154e7], y0, max_step=1000) # 1 year plt.plot(sol.y[0]/AU, sol.y[1]/AU, label=f'{v/1e3:.0f} km/s') sun = plt.Circle((0, 0), R_sun / AU, color='orange', alpha=0.5) plt.gca().add_artist(sun) plt.title(\"Payload Trajectories from 1 AU (Sun-Centered)\") plt.xlabel(\"X Position (AU)\") plt.ylabel(\"Y Position (AU)\") plt.grid(True) plt.axis('equal') plt.legend(title=\"Initial Velocity\") plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#output-plot-observations","text":"This plot clearly shows: 5.0\u20137.0 km/s: Payload crashes back to Earth 7.5\u20138.5 km/s: Elliptical and nearly circular orbits 11.2 km/s+: Escape velocities, resulting in open hyperbolic trajectories D\u00fcnya yar\u0131\u00e7ap\u0131 orant\u0131l\u0131 mavi daire ile \u00e7izildi. Payload ba\u015flama noktas\u0131 800 km yukar\u0131da ve D\u00fcnya'n\u0131n sa\u011f\u0131ndad\u0131r, hocan\u0131n belirtti\u011fi gibi.","title":"Output Plot &amp; Observations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-relevance","text":"Use Case Velocity Range Outcome LEO Satellite Deployment ~7.5 km/s Circular/Elliptical orbit ISS Missions ~7.66 km/s Stable LEO orbit Lunar / Mars Missions >11.2 km/s Escape trajectory (v\u2082) Reentry Capsule <7.5 km/s Controlled fall or crash","title":"Real-World Relevance"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"Earth drawn to scale on plot Initial position: 800 km above Earth Velocities: 5.0 to 13.0 km/s (in 0.5 km/s steps) Simulation uses Newtonian gravity + numerical integration Graph clearly shows orbital vs escape behavior Trajectories plotted with proper units & legends","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#colab-link","text":"Colab \u2013 Gravity Problem 3 Simulation","title":"Colab Link"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Waves Problem Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns show how waves combine either constructively (amplifying) or destructively (canceling out). Studying these patterns helps us understand wave behavior in a visual and intuitive way. It introduces concepts like phase difference, wavelength, frequency, and superposition of waves. Task Description A circular wave on the water surface, emanating from a point source at \\((x_0, y_0)\\) , is described by the single disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : displacement at point \\((x, y)\\) and time \\(t\\) \\(A\\) : amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number (related to wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) : angular frequency (related to frequency \\(f\\) ) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from source to point \\(\\phi\\) : initial phase Problem Statement Your task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. Steps to Follow Choose a Regular Polygon (e.g., triangle, square, pentagon) Place Sources at the vertices Apply the wave equation for each source Superposition : $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) $$ Visualize both 2D (heatmap) and 3D surface plots of \\(\\eta_{\\text{sum}}(x, y, t)\\) Analyze zones of constructive/destructive interference Python Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1 omega = 2 * np.pi * f phi = 0 # Create regular polygon (e.g., pentagon) N = 5 R = 5 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R*np.cos(a), R*np.sin(a)) for a in angles] # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Time snapshot t = 0 eta_total = np.zeros_like(X) # Superpose waves for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = A / np.sqrt(r) * np.cos(k * r - omega * t + phi) eta_total += eta # 2D Heatmap plt.figure(figsize=(8,6)) plt.contourf(X, Y, eta_total, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.title('2D Interference Pattern (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.tight_layout() plt.show() # 3D Surface Plot fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta_total, cmap='viridis', edgecolor='none', alpha=0.85) ax.set_title('3D Surface Plot of Wave Interference') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') plt.tight_layout() plt.show() Observations Areas where waves amplify each other show constructive interference. Areas where waves cancel each other show destructive interference. Symmetry of the polygon affects the symmetry of the interference pattern. Animation import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1 omega = 2 * np.pi * f phi = 0 N = 5 R = 5 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R*np.cos(a), R*np.sin(a)) for a in angles] x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) fig, ax = plt.subplots(figsize=(6, 6)) cax = ax.imshow(np.zeros_like(X), extent=[-10, 10, 10, -10], cmap='coolwarm', origin='upper', animated=True) ax.set_title('Wave Interference Animation (Pentagon)') ax.set_xlabel('x') ax.set_ylabel('y') plt.colorbar(cax, ax=ax, label='Displacement') def update(t): eta_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = A / np.sqrt(r) * np.cos(k * r - omega * t + phi) eta_total += eta cax.set_array(eta_total) return [cax] ani = animation.FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 60), interval=100, blit=True) gif_path = \"/content/wave_interference_pentagon.gif\" ani.save(gif_path, writer='pillow', fps=10) gif_path Colab - Animation Colab Link Colab \u2013 Waves Simulation","title":"Waves Problem"},{"location":"1%20Physics/3%20Waves/Problem_1/#waves-problem","text":"","title":"Waves Problem"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns show how waves combine either constructively (amplifying) or destructively (canceling out). Studying these patterns helps us understand wave behavior in a visual and intuitive way. It introduces concepts like phase difference, wavelength, frequency, and superposition of waves.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-description","text":"A circular wave on the water surface, emanating from a point source at \\((x_0, y_0)\\) , is described by the single disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : displacement at point \\((x, y)\\) and time \\(t\\) \\(A\\) : amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number (related to wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) : angular frequency (related to frequency \\(f\\) ) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from source to point \\(\\phi\\) : initial phase","title":"Task Description"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Your task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Choose a Regular Polygon (e.g., triangle, square, pentagon) Place Sources at the vertices Apply the wave equation for each source Superposition : $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) $$ Visualize both 2D (heatmap) and 3D surface plots of \\(\\eta_{\\text{sum}}(x, y, t)\\) Analyze zones of constructive/destructive interference","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1 omega = 2 * np.pi * f phi = 0 # Create regular polygon (e.g., pentagon) N = 5 R = 5 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R*np.cos(a), R*np.sin(a)) for a in angles] # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Time snapshot t = 0 eta_total = np.zeros_like(X) # Superpose waves for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = A / np.sqrt(r) * np.cos(k * r - omega * t + phi) eta_total += eta # 2D Heatmap plt.figure(figsize=(8,6)) plt.contourf(X, Y, eta_total, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.title('2D Interference Pattern (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.tight_layout() plt.show() # 3D Surface Plot fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta_total, cmap='viridis', edgecolor='none', alpha=0.85) ax.set_title('3D Surface Plot of Wave Interference') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"Areas where waves amplify each other show constructive interference. Areas where waves cancel each other show destructive interference. Symmetry of the polygon affects the symmetry of the interference pattern.","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#animation","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1 omega = 2 * np.pi * f phi = 0 N = 5 R = 5 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R*np.cos(a), R*np.sin(a)) for a in angles] x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) fig, ax = plt.subplots(figsize=(6, 6)) cax = ax.imshow(np.zeros_like(X), extent=[-10, 10, 10, -10], cmap='coolwarm', origin='upper', animated=True) ax.set_title('Wave Interference Animation (Pentagon)') ax.set_xlabel('x') ax.set_ylabel('y') plt.colorbar(cax, ax=ax, label='Displacement') def update(t): eta_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = A / np.sqrt(r) * np.cos(k * r - omega * t + phi) eta_total += eta cax.set_array(eta_total) return [cax] ani = animation.FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 60), interval=100, blit=True) gif_path = \"/content/wave_interference_pentagon.gif\" ani.save(gif_path, writer='pillow', fps=10) gif_path Colab - Animation","title":"Animation"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab-link","text":"Colab \u2013 Waves Simulation","title":"Colab Link"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}