{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, though seemingly simple, presents a deep and rich structure when examined thoroughly. By studying how the range of a projectile depends on the launch angle, we reveal fundamental principles of kinematics and dynamics. Variables like initial velocity, gravitational acceleration, and launch height provide a broad variety of solutions, applicable to real-world situations such as sports, engineering, and space science. Theoretical Foundation Starting from the basic laws of motion, we can derive the projectile equations. Assume no air resistance and flat terrain. Let: \\(v_0\\) = Initial velocity \\(\\theta\\) = Angle of projection \\(g\\) = Gravitational acceleration The equations of motion are: $$ \\frac{d^2x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) $$ \\[ \\frac{d^2y}{dt^2} = -g \\quad \\Rightarrow \\quad \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\] Integrating these: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] Time of Flight Setting \\(y = 0\\) at landing: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2}gT^2 \\] Solving for T \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range Horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum Height The maximum vertical position: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] Observations Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , that is, \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effects of parameters \\(v_0\\) : Range increases quadratically with initial velocity. \\(g\\) : Range decreases inversely with gravitational acceleration. Launch height: Would modify the symmetry and the optimal angle if included. Practical Applications Sports: Finding the best launch angles for throws, shots, or kicks. Engineering: Ballistics calculations. Astrophysics: Launching satellites or projectiles from planetary surfaces. Including air resistance, wind, or launching from non-level terrain are real-world complications addressed with numerical methods. Implementation Below are Python scripts simulating projectile motion under the given scenarios. import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 1: 45\u00b0 angle, different velocities (30, 40, 50 m/s) import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 2: 50 m/s, different angles (15\u00b0, 45\u00b0, 75\u00b0) angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representations In the first plot, as initial velocity increases, range increases significantly. angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() In the second plot, \\(45^\\circ\\) provides the maximum range, while \\(15^\\circ\\) and \\(75^\\circ\\) give the same (shorter) range. Limitations and Extensions Limitations No air resistance considered. Flat launch and landing height assumed. Extensions Include air resistance: drag force proportional to velocity. Launch from or land on elevated platforms. Add wind effects. Summary Analyzing projectile motion illustrates fundamental physics while also introducing opportunities for deeper exploration using computational methods. Studying range as a function of launch angle helps us understand both idealized and real-world trajectories. Colab Link Colab - Problem 1 Simulation","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, though seemingly simple, presents a deep and rich structure when examined thoroughly. By studying how the range of a projectile depends on the launch angle, we reveal fundamental principles of kinematics and dynamics. Variables like initial velocity, gravitational acceleration, and launch height provide a broad variety of solutions, applicable to real-world situations such as sports, engineering, and space science.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"Starting from the basic laws of motion, we can derive the projectile equations. Assume no air resistance and flat terrain. Let: \\(v_0\\) = Initial velocity \\(\\theta\\) = Angle of projection \\(g\\) = Gravitational acceleration The equations of motion are: $$ \\frac{d^2x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) $$ \\[ \\frac{d^2y}{dt^2} = -g \\quad \\Rightarrow \\quad \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\] Integrating these: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Setting \\(y = 0\\) at landing: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2}gT^2 \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solving-for-t","text":"\\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Solving for T"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"Horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#maximum-height","text":"The maximum vertical position: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , that is, \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effects of parameters \\(v_0\\) : Range increases quadratically with initial velocity. \\(g\\) : Range decreases inversely with gravitational acceleration. Launch height: Would modify the symmetry and the optimal angle if included. Practical Applications Sports: Finding the best launch angles for throws, shots, or kicks. Engineering: Ballistics calculations. Astrophysics: Launching satellites or projectiles from planetary surfaces. Including air resistance, wind, or launching from non-level terrain are real-world complications addressed with numerical methods.","title":"Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"Below are Python scripts simulating projectile motion under the given scenarios. import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 1: 45\u00b0 angle, different velocities (30, 40, 50 m/s) import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$v_0$ = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 2: 50 m/s, different angles (15\u00b0, 45\u00b0, 75\u00b0) angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representations In the first plot, as initial velocity increases, range increases significantly. angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f'$\\\\theta$ = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() In the second plot, \\(45^\\circ\\) provides the maximum range, while \\(15^\\circ\\) and \\(75^\\circ\\) give the same (shorter) range.","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"Limitations No air resistance considered. Flat launch and landing height assumed. Extensions Include air resistance: drag force proportional to velocity. Launch from or land on elevated platforms. Add wind effects.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Analyzing projectile motion illustrates fundamental physics while also introducing opportunities for deeper exploration using computational methods. Studying range as a function of launch angle helps us understand both idealized and real-world trajectories.","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab-link","text":"Colab - Problem 1 Simulation","title":"Colab Link"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Dynamics of a Forced Damped Pendulum: A Computational Exploration Motivation The forced damped pendulum is a key system in nonlinear dynamics. When damping and external periodic forces act on a pendulum, its behavior ranges from predictable oscillations to complex and chaotic motion. This diversity reflects many real-world systems \u2014 from electronics to biomechanics. By tuning parameters like the damping factor and the strength and frequency of the driving force, we observe phenomena such as resonance, quasiperiodicity, and transitions to chaos. These insights are fundamental in understanding oscillatory systems in engineering, physics, and nature. 1. Mathematical Framework Differential Equation The system is modeled by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement - \\(b\\) : damping coefficient - \\(g\\) : gravitational acceleration - \\(L\\) : length of pendulum - \\(A\\) : external driving amplitude - \\(\\omega\\) : angular frequency of the driving force Linear Approximation (Small Angle) For small angular displacements: \\[ \\sin\\theta \\approx \\theta \\] Reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This linear form simplifies simulation and helps analyze regular behavior before chaos emerges. 2. Parameter-Based Behavior Analysis We analyze system behavior by varying: Damping coefficient \\(b\\) Driving amplitude \\(A\\) Driving frequency \\(\\omega\\) This helps reveal: - Transition from underdamped to overdamped behavior - Resonance and amplification - Onset of chaotic regimes 3. Real-World Relevance This model describes: - Suspension systems in vehicles - Oscillating electrical circuits (e.g., RLC) - Structures under periodic stress - Biological movement patterns (gait dynamics) 4. Python Modeling Below is a simulation using solve_ivp from scipy.integrate to model pendulum behavior for different conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def dynamics(t, y, b, g, L, A, omega): theta, omega_ = y return [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] # Setup y0 = [0.15, 0.0] t_range = (0, 60) t_eval = np.linspace(*t_range, 1500) cases = [ {\"label\": \"Light Damping\", \"b\": 0.1, \"A\": 0.8, \"omega\": 1.0, \"color\": \"royalblue\"}, {\"label\": \"Critical Damping\", \"b\": 0.6, \"A\": 0.8, \"omega\": 1.0, \"color\": \"firebrick\"}, {\"label\": \"High Drive\", \"b\": 0.3, \"A\": 1.8, \"omega\": 3.0, \"color\": \"darkgreen\"}, ] g = 9.8 L = 1.0 fig, axes = plt.subplots(len(cases), 2, figsize=(12, 11)) for i, c in enumerate(cases): sol = solve_ivp( dynamics, t_range, y0, args=(c[\"b\"], g, L, c[\"A\"], c[\"omega\"]), t_eval=t_eval ) theta, omega_ = sol.y axes[i, 0].plot(sol.t, theta, color=c[\"color\"]) axes[i, 0].set_title(f'{c[\"label\"]} - \u03b8(t)') axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"\u03b8 (rad)\") axes[i, 0].grid() axes[i, 1].plot(theta, omega_, color=c[\"color\"]) axes[i, 1].set_title(f'{c[\"label\"]} - Phase Diagram') axes[i, 1].set_xlabel(\"\u03b8 (rad)\") axes[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axes[i, 1].grid() plt.tight_layout() plt.show() <<<<<<< HEAD ======= - 5. Simulation Outcomes Light Damping - Oscillations persist - Phase plot shows large elliptical orbits Critical Damping - Motion stabilizes quickly - System returns to equilibrium smoothly High Drive - Complex motion develops - Phase space suggests early chaos 6. Summary and Future Work This experiment demonstrates how driven damped pendulums can show both stability and complexity, depending on parameters. Possible extensions: - Generate bifurcation diagrams for varying \\(\\omega\\) - Add nonlinear damping - Analyze long-term chaos with Poincar\u00e9 maps These tools help bridge theory with systems seen in engineering, nature, and modern physics.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#dynamics-of-a-forced-damped-pendulum-a-computational-exploration","text":"","title":"Dynamics of a Forced Damped Pendulum: A Computational Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a key system in nonlinear dynamics. When damping and external periodic forces act on a pendulum, its behavior ranges from predictable oscillations to complex and chaotic motion. This diversity reflects many real-world systems \u2014 from electronics to biomechanics. By tuning parameters like the damping factor and the strength and frequency of the driving force, we observe phenomena such as resonance, quasiperiodicity, and transitions to chaos. These insights are fundamental in understanding oscillatory systems in engineering, physics, and nature.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-mathematical-framework","text":"","title":"1. Mathematical Framework"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The system is modeled by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement - \\(b\\) : damping coefficient - \\(g\\) : gravitational acceleration - \\(L\\) : length of pendulum - \\(A\\) : external driving amplitude - \\(\\omega\\) : angular frequency of the driving force","title":"Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#linear-approximation-small-angle","text":"For small angular displacements: \\[ \\sin\\theta \\approx \\theta \\] Reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This linear form simplifies simulation and helps analyze regular behavior before chaos emerges.","title":"Linear Approximation (Small Angle)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-parameter-based-behavior-analysis","text":"We analyze system behavior by varying: Damping coefficient \\(b\\) Driving amplitude \\(A\\) Driving frequency \\(\\omega\\) This helps reveal: - Transition from underdamped to overdamped behavior - Resonance and amplification - Onset of chaotic regimes","title":"2. Parameter-Based Behavior Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-relevance","text":"This model describes: - Suspension systems in vehicles - Oscillating electrical circuits (e.g., RLC) - Structures under periodic stress - Biological movement patterns (gait dynamics)","title":"3. Real-World Relevance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-modeling","text":"Below is a simulation using solve_ivp from scipy.integrate to model pendulum behavior for different conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def dynamics(t, y, b, g, L, A, omega): theta, omega_ = y return [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] # Setup y0 = [0.15, 0.0] t_range = (0, 60) t_eval = np.linspace(*t_range, 1500) cases = [ {\"label\": \"Light Damping\", \"b\": 0.1, \"A\": 0.8, \"omega\": 1.0, \"color\": \"royalblue\"}, {\"label\": \"Critical Damping\", \"b\": 0.6, \"A\": 0.8, \"omega\": 1.0, \"color\": \"firebrick\"}, {\"label\": \"High Drive\", \"b\": 0.3, \"A\": 1.8, \"omega\": 3.0, \"color\": \"darkgreen\"}, ] g = 9.8 L = 1.0 fig, axes = plt.subplots(len(cases), 2, figsize=(12, 11)) for i, c in enumerate(cases): sol = solve_ivp( dynamics, t_range, y0, args=(c[\"b\"], g, L, c[\"A\"], c[\"omega\"]), t_eval=t_eval ) theta, omega_ = sol.y axes[i, 0].plot(sol.t, theta, color=c[\"color\"]) axes[i, 0].set_title(f'{c[\"label\"]} - \u03b8(t)') axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"\u03b8 (rad)\") axes[i, 0].grid() axes[i, 1].plot(theta, omega_, color=c[\"color\"]) axes[i, 1].set_title(f'{c[\"label\"]} - Phase Diagram') axes[i, 1].set_xlabel(\"\u03b8 (rad)\") axes[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axes[i, 1].grid() plt.tight_layout() plt.show() <<<<<<< HEAD ======= -","title":"4. Python Modeling"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-simulation-outcomes","text":"Light Damping - Oscillations persist - Phase plot shows large elliptical orbits Critical Damping - Motion stabilizes quickly - System returns to equilibrium smoothly High Drive - Complex motion develops - Phase space suggests early chaos","title":"5. Simulation Outcomes"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-summary-and-future-work","text":"This experiment demonstrates how driven damped pendulums can show both stability and complexity, depending on parameters. Possible extensions: - Generate bifurcation diagrams for varying \\(\\omega\\) - Add nonlinear damping - Analyze long-term chaos with Poincar\u00e9 maps These tools help bridge theory with systems seen in engineering, nature, and modern physics.","title":"6. Summary and Future Work"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Gravity Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental relationship enables us to determine planetary motions and understand gravitational interactions on both local and cosmic scales. Derivation of Kepler's Third Law Consider a satellite or planet of mass \\(m\\) orbiting a much larger central body of mass \\(M\\) in a circular orbit. The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\(m\\) and simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) is the time it takes to complete one full orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) into the expression: \\[ T = 2 \\pi r \\sqrt{\\frac{1}{G M}} \\cdot \\sqrt{r} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This is the classical form of Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\] Verification Using Planetary Data We use data from the inner planets of the solar system: Mercury, Venus, Earth, and Mars. import matplotlib.pyplot as plt import numpy as np AU = 1.496e11 G = 6.67430e-11 M_sun = 1.989e30 planet_names = ['Mercury', 'Venus', 'Earth', 'Mars'] radii_au = np.array([0.39, 0.72, 1.00, 1.52]) radii_m = radii_au * AU periods_days = np.array([88, 225, 365.25, 687]) periods_sec = periods_days * 24 * 3600 T_squared = periods_sec ** 2 r_cubed = radii_m ** 3 # Theoretical Kepler's Third Law line: T^2 = (4\u03c0\u00b2 / GM) * r^3 kepler_constant = (4 * np.pi ** 2) / (G * M_sun) r_range = np.linspace(min(r_cubed), max(r_cubed), 100) T_squared_theoretical = kepler_constant * r_range plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o', label='Planets') plt.plot(r_range, T_squared_theoretical, '-', label=\"Kepler's Law\", linewidth=2) # Label each point for i, name in enumerate(planet_names): plt.text(r_cubed[i] * 1.01, T_squared[i] * 1.01, name) plt.xlabel('$r^3$ (m$^3$)', fontsize=12) plt.ylabel('$T^2$ (s$^2$)', fontsize=12) plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\", fontsize=14) plt.grid(True) plt.legend() plt.tight_layout() plt.show() This plot should display a linear relationship, confirming the dependence: \\[ T^2 \\propto r^3 \\] Calculating the Mass of the Sun From the rearranged form of Kepler's Third Law: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Using Earth's orbital parameters: \\(r = 1.496 \\times 10^{11} \\ \\text{m}\\) \\(T = 365.25 \\ \\text{days} = 3.156 \\times 10^7 \\ \\text{s}\\) Plug in values: \\[ M = \\frac{4 \\pi^2 (1.496 \\times 10^{11})^3}{6.67430 \\times 10^{-11} \\cdot (3.156 \\times 10^7)^2} \\approx 1.989 \\times 10^{30} \\ \\text{kg} \\] This result matches the known mass of the Sun. Extension to Elliptical Orbits Kepler\u2019s Third Law applies to elliptical orbits as well, where \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\] Summary Derived \\(T^2 = \\frac{4 \\pi^2 r^3}{G M}\\) Verified \\(T^2 \\propto r^3\\) using Solar System data Estimated the mass of the Sun Generalized to elliptical orbits Colab Link Colab - Gravity Problem 1 Simulation","title":"Gravity Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-problem-1","text":"","title":"Gravity Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This fundamental relationship enables us to determine planetary motions and understand gravitational interactions on both local and cosmic scales.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"Consider a satellite or planet of mass \\(m\\) orbiting a much larger central body of mass \\(M\\) in a circular orbit. The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\(m\\) and simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) is the time it takes to complete one full orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) into the expression: \\[ T = 2 \\pi r \\sqrt{\\frac{1}{G M}} \\cdot \\sqrt{r} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] This is the classical form of Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\]","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verification-using-planetary-data","text":"We use data from the inner planets of the solar system: Mercury, Venus, Earth, and Mars. import matplotlib.pyplot as plt import numpy as np AU = 1.496e11 G = 6.67430e-11 M_sun = 1.989e30 planet_names = ['Mercury', 'Venus', 'Earth', 'Mars'] radii_au = np.array([0.39, 0.72, 1.00, 1.52]) radii_m = radii_au * AU periods_days = np.array([88, 225, 365.25, 687]) periods_sec = periods_days * 24 * 3600 T_squared = periods_sec ** 2 r_cubed = radii_m ** 3 # Theoretical Kepler's Third Law line: T^2 = (4\u03c0\u00b2 / GM) * r^3 kepler_constant = (4 * np.pi ** 2) / (G * M_sun) r_range = np.linspace(min(r_cubed), max(r_cubed), 100) T_squared_theoretical = kepler_constant * r_range plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o', label='Planets') plt.plot(r_range, T_squared_theoretical, '-', label=\"Kepler's Law\", linewidth=2) # Label each point for i, name in enumerate(planet_names): plt.text(r_cubed[i] * 1.01, T_squared[i] * 1.01, name) plt.xlabel('$r^3$ (m$^3$)', fontsize=12) plt.ylabel('$T^2$ (s$^2$)', fontsize=12) plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\", fontsize=14) plt.grid(True) plt.legend() plt.tight_layout() plt.show() This plot should display a linear relationship, confirming the dependence: \\[ T^2 \\propto r^3 \\]","title":"Verification Using Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-the-mass-of-the-sun","text":"From the rearranged form of Kepler's Third Law: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Using Earth's orbital parameters: \\(r = 1.496 \\times 10^{11} \\ \\text{m}\\) \\(T = 365.25 \\ \\text{days} = 3.156 \\times 10^7 \\ \\text{s}\\) Plug in values: \\[ M = \\frac{4 \\pi^2 (1.496 \\times 10^{11})^3}{6.67430 \\times 10^{-11} \\cdot (3.156 \\times 10^7)^2} \\approx 1.989 \\times 10^{30} \\ \\text{kg} \\] This result matches the known mass of the Sun.","title":"Calculating the Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law applies to elliptical orbits as well, where \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\]","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"Derived \\(T^2 = \\frac{4 \\pi^2 r^3}{G M}\\) Verified \\(T^2 \\propto r^3\\) using Solar System data Estimated the mass of the Sun Generalized to elliptical orbits","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#colab-link","text":"Colab - Gravity Problem 1 Simulation","title":"Colab Link"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Gravity Problem 2 Escape Velocities and Cosmic Velocities Motivation Understanding escape and cosmic velocities is essential in space exploration. These velocities determine the energy required to reach orbit, escape a planet\u2019s gravity, or leave an entire planetary system. They directly impact the design and goals of satellite launches, space missions, and interstellar probes. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is the orbital speed required to maintain a circular orbit near the surface of a planet: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\(G\\) = Gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg\u00b7s\u00b2) - \\(M\\) = Mass of the planet - \\(r\\) = Radius of the planet Second Cosmic Velocity ( \\(v_2\\) ) The second cosmic velocity is the escape velocity required to completely overcome the gravitational pull of a planet: \\[ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} \\] Third Cosmic Velocity ( \\(v_3\\) ) The third cosmic velocity is the minimum speed required to escape the gravity of a planetary system : \\[ v_3 = \\sqrt{v_2^2 + v_{sun}^2} \\] Where \\(v_{sun}\\) is Earth\u2019s orbital velocity around the Sun. Derivations 1. First Cosmic Velocity: From Newton\u2019s law of gravitation and centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v = \\sqrt{\\frac{G M}{r}} \\] 2. Second Cosmic Velocity: From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{G M m}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2 G M}{r}} \\] 3. Third Cosmic Velocity: \\[ v_3 = \\sqrt{v_{\\text{escape}}^2 + v_E^2} \\] Where \\(v_E \\approx 29.78\\) km/s is Earth\u2019s orbital velocity around the Sun. Calculations for Earth, Mars, and Jupiter import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.3895e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } results = {} for name, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 results[name] = {\"v1\": v1, \"v2\": v2} v_sun = 29.78e3 v2_earth = results[\"Earth\"][\"v2\"] v3 = np.sqrt(v2_earth**2 + v_sun**2) results[\"Earth\"][\"v3\"] = v3 for name, vels in results.items(): print(f\"{name}:\") for key, val in vels.items(): print(f\" {key}: {val/1000:.2f} km/s\") Earth: v1: 7.91 km/s v2: 11.19 km/s v3: 31.81 km/s Mars: v1: 3.55 km/s v2: 5.03 km/s Jupiter: v1: 42.57 km/s v2: 60.20 km/s import numpy as np import matplotlib.pyplot as plt # Cosmic velocity data (from previous calculations) results = { \"Earth\": {\"v1\": 7910, \"v2\": 11180, \"v3\": 42150}, \"Mars\": {\"v1\": 3550, \"v2\": 5020}, \"Jupiter\": {\"v1\": 42040, \"v2\": 59450} } labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Visualization of Velocities labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Trajectory Simulation: Gravitational Escape Behavior This plot shows the result of simulating multiple payloads launched from 800 km altitude with varying initial speeds (5 km/s to 13 km/s). It visually demonstrates: Sub-orbital fall back Closed elliptical orbits Parabolic trajectory (near escape) Open hyperbolic escape paths Space Exploration Relevance \\(v_1\\) : Low Earth orbit missions (e.g., satellites, ISS) \\(v_2\\) : Moon missions, Mars rovers, interplanetary probes \\(v_3\\) : Voyager missions, future interstellar missions Summary Derived \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Derived \\(v_2 = \\sqrt{2 G M / r}\\) from energy conservation Defined and visualized \\(v_3\\) from planetary system escape Compared Earth, Mars, Jupiter using bar chart Verified with realistic trajectory graph from 800 km altitude Related each velocity to mission types (LEO, interplanetary, interstellar) Colab Link Colab - Gravity Problem 2 Simulation (https://colab.research.google.com/drive/1jfB5XwMR-niVb6iwQM4RxY5tDNKTG0mm?usp=sharing)","title":"Gravity Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravity-problem-2","text":"","title":"Gravity Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding escape and cosmic velocities is essential in space exploration. These velocities determine the energy required to reach orbit, escape a planet\u2019s gravity, or leave an entire planetary system. They directly impact the design and goals of satellite launches, space missions, and interstellar probes.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The first cosmic velocity is the orbital speed required to maintain a circular orbit near the surface of a planet: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\(G\\) = Gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg\u00b7s\u00b2) - \\(M\\) = Mass of the planet - \\(r\\) = Radius of the planet","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The second cosmic velocity is the escape velocity required to completely overcome the gravitational pull of a planet: \\[ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} \\]","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"The third cosmic velocity is the minimum speed required to escape the gravity of a planetary system : \\[ v_3 = \\sqrt{v_2^2 + v_{sun}^2} \\] Where \\(v_{sun}\\) is Earth\u2019s orbital velocity around the Sun.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivations","text":"","title":"Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity","text":"From Newton\u2019s law of gravitation and centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v = \\sqrt{\\frac{G M}{r}} \\]","title":"1. First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity","text":"From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{G M m}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2 G M}{r}} \\]","title":"2. Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"\\[ v_3 = \\sqrt{v_{\\text{escape}}^2 + v_E^2} \\] Where \\(v_E \\approx 29.78\\) km/s is Earth\u2019s orbital velocity around the Sun.","title":"3. Third Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-earth-mars-and-jupiter","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.3895e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } results = {} for name, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 results[name] = {\"v1\": v1, \"v2\": v2} v_sun = 29.78e3 v2_earth = results[\"Earth\"][\"v2\"] v3 = np.sqrt(v2_earth**2 + v_sun**2) results[\"Earth\"][\"v3\"] = v3 for name, vels in results.items(): print(f\"{name}:\") for key, val in vels.items(): print(f\" {key}: {val/1000:.2f} km/s\") Earth: v1: 7.91 km/s v2: 11.19 km/s v3: 31.81 km/s Mars: v1: 3.55 km/s v2: 5.03 km/s Jupiter: v1: 42.57 km/s v2: 60.20 km/s import numpy as np import matplotlib.pyplot as plt # Cosmic velocity data (from previous calculations) results = { \"Earth\": {\"v1\": 7910, \"v2\": 11180, \"v3\": 42150}, \"Mars\": {\"v1\": 3550, \"v2\": 5020}, \"Jupiter\": {\"v1\": 42040, \"v2\": 59450} } labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Calculations for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization-of-velocities","text":"labels = list(results.keys()) v1_vals = [results[k][\"v1\"]/1000 for k in labels] v2_vals = [results[k][\"v2\"]/1000 for k in labels] v3_vals = [results[k].get(\"v3\", 0)/1000 for k in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) rects1 = ax.bar(x - width, v1_vals, width, label='v1: Orbit') rects2 = ax.bar(x, v2_vals, width, label='v2: Escape') rects3 = ax.bar(x + width, v3_vals, width, label='v3: Leave System') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Visualization of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#trajectory-simulation-gravitational-escape-behavior","text":"This plot shows the result of simulating multiple payloads launched from 800 km altitude with varying initial speeds (5 km/s to 13 km/s). It visually demonstrates: Sub-orbital fall back Closed elliptical orbits Parabolic trajectory (near escape) Open hyperbolic escape paths","title":"Trajectory Simulation: Gravitational Escape Behavior"},{"location":"1%20Physics/2%20Gravity/Problem_2/#space-exploration-relevance","text":"\\(v_1\\) : Low Earth orbit missions (e.g., satellites, ISS) \\(v_2\\) : Moon missions, Mars rovers, interplanetary probes \\(v_3\\) : Voyager missions, future interstellar missions","title":"Space Exploration Relevance"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"Derived \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Derived \\(v_2 = \\sqrt{2 G M / r}\\) from energy conservation Defined and visualized \\(v_3\\) from planetary system escape Compared Earth, Mars, Jupiter using bar chart Verified with realistic trajectory graph from 800 km altitude Related each velocity to mission types (LEO, interplanetary, interstellar)","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab-link","text":"Colab - Gravity Problem 2 Simulation (https://colab.research.google.com/drive/1jfB5XwMR-niVb6iwQM4RxY5tDNKTG0mm?usp=sharing)","title":"Colab Link"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Gravity Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces . This problem combines orbital mechanics and numerical simulations . Understanding these trajectories is vital for: Satellite deployment Orbital insertion Reentry planning Escape missions from Earth Theoretical Background Gravitational force acting on a mass: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\( G = 6.67430 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) (Gravitational constant) - \\( M \\) is the Earth's mass - \\( m \\) is the payload mass - \\( r \\) is the distance from the center of Earth Energy-Based Trajectory Classification: Total mechanical energy: $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} $$ If \\( E < 0 \\) \u2192 Elliptical Orbit If \\( E = 0 \\) \u2192 Parabolic Trajectory If \\( E > 0 \\) \u2192 Hyperbolic Trajectory Simulation Parameters Initial altitude = 800 km above Earth's surface Start point is placed at (0, R + 800e3) \u2192 clearly visible to the right of Earth Initial velocities from 5.0 km/s to 13.0 km/s , with 0.5 km/s increments Python Simulation Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import matplotlib.animation as animation from IPython.display import HTML G = 6.67430e-11 # Evrensel \u00e7ekim sabiti M = 5.972e24 # D\u00fcnya k\u00fctlesi (kg) R_earth = 6.371e6 # D\u00fcnya yar\u0131\u00e7ap\u0131 (m) altitude = 800e3 # Ba\u015flang\u0131\u00e7 y\u00fcksekli\u011fi (800 km) r0 = R_earth + altitude velocities = [5e3, 7.5e3, 11.5e3] # km/s: 5.0, 7.5, 11.5 colors = ['red', 'green', 'blue'] labels = ['5.0 km/s', '7.5 km/s', '11.5 km/s'] trajectories = [] def motion(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] for v in velocities: y0 = [0, r0, v, 0] # pozisyon ve h\u0131z sol = solve_ivp(motion, [0, 7000], y0, max_step=5) trajectories.append((sol.y[0] / 1e6, sol.y[1] / 1e6)) # km cinsinden fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-10, 30) ax.set_ylim(-10, 30) ax.set_xlabel('X (1000 km)') ax.set_ylabel('Y (1000 km)') ax.set_title('Payload Trajectories Animation') ax.grid(True) earth = plt.Circle((0, 0), R_earth / 1e6, color='blue', alpha=0.3) ax.add_patch(earth) lines = [ax.plot([], [], color=c, label=l)[0] for c, l in zip(colors, labels)] points = [ax.plot([], [], 'o', color=c)[0] for c in colors] ax.legend() def init(): for line, point in zip(lines, points): line.set_data([], []) point.set_data([], []) return lines + points def update(frame): for i, (x, y) in enumerate(trajectories): if frame < len(x): lines[i].set_data(x[:frame], y[:frame]) points[i].set_data([x[frame]], [y[frame]]) # Pass as sequences return lines + points ani = animation.FuncAnimation(fig, update, frames=400, init_func=init, blit=True, interval=40) HTML(ani.to_jshtml()) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp G = 6.67430e-11 # Universal gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) R_sun = 6.9634e8 # Radius of the Sun (m) AU = 1.496e11 # 1 Astronomical Unit in meters r0 = AU # Starting position 1 AU from the Sun def motion(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M_sun * x / r**3 ay = -G * M_sun * y_pos / r**3 return [vx, vy, ax, ay] velocities = np.arange(25e3, 52e3, 5e3) # In m/s plt.figure(figsize=(10, 10)) for v in velocities: y0 = [r0, 0, 0, v] # Initial pos at 1 AU on x-axis, velocity in +y direction sol = solve_ivp(motion, [0, 3.154e7], y0, max_step=1000) # 1 year plt.plot(sol.y[0]/AU, sol.y[1]/AU, label=f'{v/1e3:.0f} km/s') sun = plt.Circle((0, 0), R_sun / AU, color='orange', alpha=0.5) plt.gca().add_artist(sun) plt.title(\"Payload Trajectories from 1 AU (Sun-Centered)\") plt.xlabel(\"X Position (AU)\") plt.ylabel(\"Y Position (AU)\") plt.grid(True) plt.axis('equal') plt.legend(title=\"Initial Velocity\") plt.tight_layout() plt.show() Output Plot & Observations This plot clearly shows: 5.0\u20137.0 km/s: Payload crashes back to Earth 7.5\u20138.5 km/s: Elliptical and nearly circular orbits 11.2 km/s+: Escape velocities, resulting in open hyperbolic trajectories D\u00fcnya yar\u0131\u00e7ap\u0131 orant\u0131l\u0131 mavi daire ile \u00e7izildi. Payload ba\u015flama noktas\u0131 800 km yukar\u0131da ve D\u00fcnya'n\u0131n sa\u011f\u0131ndad\u0131r, hocan\u0131n belirtti\u011fi gibi. Real-World Relevance Use Case Velocity Range Outcome LEO Satellite Deployment ~7.5 km/s Circular/Elliptical orbit ISS Missions ~7.66 km/s Stable LEO orbit Lunar / Mars Missions >11.2 km/s Escape trajectory (v\u2082) Reentry Capsule <7.5 km/s Controlled fall or crash Summary Earth drawn to scale on plot Initial position: 800 km above Earth Velocities: 5.0 to 13.0 km/s (in 0.5 km/s steps) Simulation uses Newtonian gravity + numerical integration Graph clearly shows orbital vs escape behavior Trajectories plotted with proper units & legends Colab Link Colab \u2013 Gravity Problem 3 Simulation","title":"Gravity Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravity-problem-3","text":"","title":"Gravity Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces . This problem combines orbital mechanics and numerical simulations . Understanding these trajectories is vital for: Satellite deployment Orbital insertion Reentry planning Escape missions from Earth","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"Gravitational force acting on a mass: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\( G = 6.67430 \\times 10^{-11} \\ \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) (Gravitational constant) - \\( M \\) is the Earth's mass - \\( m \\) is the payload mass - \\( r \\) is the distance from the center of Earth","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#energy-based-trajectory-classification","text":"Total mechanical energy: $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} $$ If \\( E < 0 \\) \u2192 Elliptical Orbit If \\( E = 0 \\) \u2192 Parabolic Trajectory If \\( E > 0 \\) \u2192 Hyperbolic Trajectory","title":"Energy-Based Trajectory Classification:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"Initial altitude = 800 km above Earth's surface Start point is placed at (0, R + 800e3) \u2192 clearly visible to the right of Earth Initial velocities from 5.0 km/s to 13.0 km/s , with 0.5 km/s increments","title":"Simulation Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import matplotlib.animation as animation from IPython.display import HTML G = 6.67430e-11 # Evrensel \u00e7ekim sabiti M = 5.972e24 # D\u00fcnya k\u00fctlesi (kg) R_earth = 6.371e6 # D\u00fcnya yar\u0131\u00e7ap\u0131 (m) altitude = 800e3 # Ba\u015flang\u0131\u00e7 y\u00fcksekli\u011fi (800 km) r0 = R_earth + altitude velocities = [5e3, 7.5e3, 11.5e3] # km/s: 5.0, 7.5, 11.5 colors = ['red', 'green', 'blue'] labels = ['5.0 km/s', '7.5 km/s', '11.5 km/s'] trajectories = [] def motion(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M * x / r**3 ay = -G * M * y_pos / r**3 return [vx, vy, ax, ay] for v in velocities: y0 = [0, r0, v, 0] # pozisyon ve h\u0131z sol = solve_ivp(motion, [0, 7000], y0, max_step=5) trajectories.append((sol.y[0] / 1e6, sol.y[1] / 1e6)) # km cinsinden fig, ax = plt.subplots(figsize=(8, 8)) ax.set_xlim(-10, 30) ax.set_ylim(-10, 30) ax.set_xlabel('X (1000 km)') ax.set_ylabel('Y (1000 km)') ax.set_title('Payload Trajectories Animation') ax.grid(True) earth = plt.Circle((0, 0), R_earth / 1e6, color='blue', alpha=0.3) ax.add_patch(earth) lines = [ax.plot([], [], color=c, label=l)[0] for c, l in zip(colors, labels)] points = [ax.plot([], [], 'o', color=c)[0] for c in colors] ax.legend() def init(): for line, point in zip(lines, points): line.set_data([], []) point.set_data([], []) return lines + points def update(frame): for i, (x, y) in enumerate(trajectories): if frame < len(x): lines[i].set_data(x[:frame], y[:frame]) points[i].set_data([x[frame]], [y[frame]]) # Pass as sequences return lines + points ani = animation.FuncAnimation(fig, update, frames=400, init_func=init, blit=True, interval=40) HTML(ani.to_jshtml()) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp G = 6.67430e-11 # Universal gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) R_sun = 6.9634e8 # Radius of the Sun (m) AU = 1.496e11 # 1 Astronomical Unit in meters r0 = AU # Starting position 1 AU from the Sun def motion(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M_sun * x / r**3 ay = -G * M_sun * y_pos / r**3 return [vx, vy, ax, ay] velocities = np.arange(25e3, 52e3, 5e3) # In m/s plt.figure(figsize=(10, 10)) for v in velocities: y0 = [r0, 0, 0, v] # Initial pos at 1 AU on x-axis, velocity in +y direction sol = solve_ivp(motion, [0, 3.154e7], y0, max_step=1000) # 1 year plt.plot(sol.y[0]/AU, sol.y[1]/AU, label=f'{v/1e3:.0f} km/s') sun = plt.Circle((0, 0), R_sun / AU, color='orange', alpha=0.5) plt.gca().add_artist(sun) plt.title(\"Payload Trajectories from 1 AU (Sun-Centered)\") plt.xlabel(\"X Position (AU)\") plt.ylabel(\"Y Position (AU)\") plt.grid(True) plt.axis('equal') plt.legend(title=\"Initial Velocity\") plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#output-plot-observations","text":"This plot clearly shows: 5.0\u20137.0 km/s: Payload crashes back to Earth 7.5\u20138.5 km/s: Elliptical and nearly circular orbits 11.2 km/s+: Escape velocities, resulting in open hyperbolic trajectories D\u00fcnya yar\u0131\u00e7ap\u0131 orant\u0131l\u0131 mavi daire ile \u00e7izildi. Payload ba\u015flama noktas\u0131 800 km yukar\u0131da ve D\u00fcnya'n\u0131n sa\u011f\u0131ndad\u0131r, hocan\u0131n belirtti\u011fi gibi.","title":"Output Plot &amp; Observations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-relevance","text":"Use Case Velocity Range Outcome LEO Satellite Deployment ~7.5 km/s Circular/Elliptical orbit ISS Missions ~7.66 km/s Stable LEO orbit Lunar / Mars Missions >11.2 km/s Escape trajectory (v\u2082) Reentry Capsule <7.5 km/s Controlled fall or crash","title":"Real-World Relevance"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"Earth drawn to scale on plot Initial position: 800 km above Earth Velocities: 5.0 to 13.0 km/s (in 0.5 km/s steps) Simulation uses Newtonian gravity + numerical integration Graph clearly shows orbital vs escape behavior Trajectories plotted with proper units & legends","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#colab-link","text":"Colab \u2013 Gravity Problem 3 Simulation","title":"Colab Link"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Waves Problem Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns show how waves combine either constructively (amplifying) or destructively (canceling out). Studying these patterns helps us understand wave behavior in a visual and intuitive way. It introduces concepts like phase difference, wavelength, frequency, and superposition of waves. Task Description A circular wave on the water surface, emanating from a point source at \\((x_0, y_0)\\) , is described by the single disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : displacement at point \\((x, y)\\) and time \\(t\\) \\(A\\) : amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number (related to wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) : angular frequency (related to frequency \\(f\\) ) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from source to point \\(\\phi\\) : initial phase Problem Statement Your task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. Steps to Follow Choose a Regular Polygon (e.g., triangle, square, pentagon) Place Sources at the vertices Apply the wave equation for each source Superposition : $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) $$ Visualize both 2D (heatmap) and 3D surface plots of \\(\\eta_{\\text{sum}}(x, y, t)\\) Analyze zones of constructive/destructive interference Python Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1 omega = 2 * np.pi * f phi = 0 # Create regular polygon (e.g., pentagon) N = 5 R = 5 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R*np.cos(a), R*np.sin(a)) for a in angles] # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Time snapshot t = 0 eta_total = np.zeros_like(X) # Superpose waves for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = A / np.sqrt(r) * np.cos(k * r - omega * t + phi) eta_total += eta # 2D Heatmap plt.figure(figsize=(8,6)) plt.contourf(X, Y, eta_total, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.title('2D Interference Pattern (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.tight_layout() plt.show() # 3D Surface Plot fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta_total, cmap='viridis', edgecolor='none', alpha=0.85) ax.set_title('3D Surface Plot of Wave Interference') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') plt.tight_layout() plt.show() Observations Areas where waves amplify each other show constructive interference. Areas where waves cancel each other show destructive interference. Symmetry of the polygon affects the symmetry of the interference pattern. Animation import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1 omega = 2 * np.pi * f phi = 0 N = 5 R = 5 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R*np.cos(a), R*np.sin(a)) for a in angles] x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) fig, ax = plt.subplots(figsize=(6, 6)) cax = ax.imshow(np.zeros_like(X), extent=[-10, 10, 10, -10], cmap='coolwarm', origin='upper', animated=True) ax.set_title('Wave Interference Animation (Pentagon)') ax.set_xlabel('x') ax.set_ylabel('y') plt.colorbar(cax, ax=ax, label='Displacement') def update(t): eta_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = A / np.sqrt(r) * np.cos(k * r - omega * t + phi) eta_total += eta cax.set_array(eta_total) return [cax] ani = animation.FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 60), interval=100, blit=True) gif_path = \"/content/wave_interference_pentagon.gif\" ani.save(gif_path, writer='pillow', fps=10) from IPython.display import Image Image(filename=gif_path) Colab - Animation Colab Link Colab \u2013 Waves Simulation","title":"Waves Problem"},{"location":"1%20Physics/3%20Waves/Problem_1/#waves-problem","text":"","title":"Waves Problem"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns show how waves combine either constructively (amplifying) or destructively (canceling out). Studying these patterns helps us understand wave behavior in a visual and intuitive way. It introduces concepts like phase difference, wavelength, frequency, and superposition of waves.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-description","text":"A circular wave on the water surface, emanating from a point source at \\((x_0, y_0)\\) , is described by the single disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : displacement at point \\((x, y)\\) and time \\(t\\) \\(A\\) : amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number (related to wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) : angular frequency (related to frequency \\(f\\) ) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : distance from source to point \\(\\phi\\) : initial phase","title":"Task Description"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Your task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Choose a Regular Polygon (e.g., triangle, square, pentagon) Place Sources at the vertices Apply the wave equation for each source Superposition : $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) $$ Visualize both 2D (heatmap) and 3D surface plots of \\(\\eta_{\\text{sum}}(x, y, t)\\) Analyze zones of constructive/destructive interference","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1 omega = 2 * np.pi * f phi = 0 # Create regular polygon (e.g., pentagon) N = 5 R = 5 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R*np.cos(a), R*np.sin(a)) for a in angles] # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Time snapshot t = 0 eta_total = np.zeros_like(X) # Superpose waves for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = A / np.sqrt(r) * np.cos(k * r - omega * t + phi) eta_total += eta # 2D Heatmap plt.figure(figsize=(8,6)) plt.contourf(X, Y, eta_total, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.title('2D Interference Pattern (Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.tight_layout() plt.show() # 3D Surface Plot fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta_total, cmap='viridis', edgecolor='none', alpha=0.85) ax.set_title('3D Surface Plot of Wave Interference') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement') plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"Areas where waves amplify each other show constructive interference. Areas where waves cancel each other show destructive interference. Symmetry of the polygon affects the symmetry of the interference pattern.","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#animation","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength f = 1 omega = 2 * np.pi * f phi = 0 N = 5 R = 5 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R*np.cos(a), R*np.sin(a)) for a in angles] x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) fig, ax = plt.subplots(figsize=(6, 6)) cax = ax.imshow(np.zeros_like(X), extent=[-10, 10, 10, -10], cmap='coolwarm', origin='upper', animated=True) ax.set_title('Wave Interference Animation (Pentagon)') ax.set_xlabel('x') ax.set_ylabel('y') plt.colorbar(cax, ax=ax, label='Displacement') def update(t): eta_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta = A / np.sqrt(r) * np.cos(k * r - omega * t + phi) eta_total += eta cax.set_array(eta_total) return [cax] ani = animation.FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 60), interval=100, blit=True) gif_path = \"/content/wave_interference_pentagon.gif\" ani.save(gif_path, writer='pillow', fps=10) from IPython.display import Image Image(filename=gif_path) Colab - Animation","title":"Animation"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab-link","text":"Colab \u2013 Waves Simulation","title":"Colab Link"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Electromagnetism Problem 1 Lorentz Force: Simulating the Motion of Charged Particles Motivation The Lorentz force , given by the equation: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] governs the motion of charged particles in electric and magnetic fields. This law is essential in understanding how charged particles behave in contexts such as: Plasma physics Particle accelerators Magnetic traps Mass spectrometers In this simulation, we use a body with q = 1 C and m = 1 gram = 0.001 kg ( not an electron!) as instructed, and analyze its behavior in: Circular motion (magnetic field only) Spiral motion (with velocity in the Z-direction) Drift motion (crossed electric and magnetic fields) Constants and Setup Charge: q = 1 C Mass: m = 0.001 kg Magnetic Field: B = [0, 0, 1] T Electric Field: E = [0, 5, 0] V/m (only for drift scenario) Equations of Motion Using Newton\u2019s Second Law: \\[ \\frac{d\\vec{v}}{dt} = \\frac{q}{m}(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Numerical integration will be done using solve_ivp from SciPy. Python Simulation Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Constants q = 1 # Charge in Coulombs m = 1 # Mass in kilograms (1 kg) B = np.array([0, 0, 1]) # Magnetic field in z-direction E = np.array([0, 5, 0]) # Electric field in y-direction # Lorentz force system def lorentz(t, y, use_electric=False): r = y[:3] v = y[3:] E_field = E if use_electric else np.array([0, 0, 0]) a = (q / m) * (E_field + np.cross(v, B)) return np.concatenate((v, a)) # Time settings dt = 1e-3 n_steps = 5000 T = dt * n_steps t_eval = np.linspace(0, T, n_steps) # Define all 3 scenarios configs = [ { \"label\": \"Circular Trajectory in Magnetic Field\", \"y0\": [0, 0, 0, 10, 0, 0], # Initial velocity in X \"use_electric\": False }, { \"label\": \"Spiral Trajectory (Z motion)\", \"y0\": [0, 0, 0, 10, 0, 2], # Initial velocity in X and Z \"use_electric\": False }, { \"label\": \"E \u00d7 B Drift\", \"y0\": [0, 0, 0, 10, 0, 0], # Initial velocity in X, electric field active \"use_electric\": True } ] # Plotting fig = plt.figure(figsize=(18, 5)) for i, config in enumerate(configs): sol = solve_ivp( lorentz, [0, T], config[\"y0\"], args=(config[\"use_electric\"],), t_eval=t_eval ) x, y, z = sol.y[0], sol.y[1], sol.y[2] ax = fig.add_subplot(1, 3, i+1, projection='3d') ax.plot(x, y, z, color='deepskyblue', lw=1.5) ax.set_title(config[\"label\"], fontsize=11) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.tick_params(labelsize=8) ax.set_xlim([min(x), max(x)]) ax.set_ylim([min(y), max(y)]) ax.set_zlim([min(z), max(z)]) ax.grid(True) plt.tight_layout() plt.show() Visualized Results Circular motion : Pure rotation in XY-plane under magnetic field only. Spiral motion : Z-velocity added causes a spiral up. Drift motion : Crossed E and B fields result in sideways drift. Each trajectory exhibits expected motion per Lorentz force dynamics. Real-World Applications Cyclotron : Particles spiral in a magnetic field. Plasma confinement : Drift motion used in tokamaks. Mass spectrometry : Circular/spiral paths reveal charge-to-mass ratio. Extension Ideas Add time-varying fields. Use non-uniform magnetic field. Animate the particle motion. Colab Link Colab Notebook - Lorentz Force Simulation","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-problem-1","text":"","title":"Electromagnetism Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulating-the-motion-of-charged-particles","text":"","title":"Lorentz Force: Simulating the Motion of Charged Particles"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force , given by the equation: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] governs the motion of charged particles in electric and magnetic fields. This law is essential in understanding how charged particles behave in contexts such as: Plasma physics Particle accelerators Magnetic traps Mass spectrometers In this simulation, we use a body with q = 1 C and m = 1 gram = 0.001 kg ( not an electron!) as instructed, and analyze its behavior in: Circular motion (magnetic field only) Spiral motion (with velocity in the Z-direction) Drift motion (crossed electric and magnetic fields)","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#constants-and-setup","text":"Charge: q = 1 C Mass: m = 0.001 kg Magnetic Field: B = [0, 0, 1] T Electric Field: E = [0, 5, 0] V/m (only for drift scenario)","title":"Constants and Setup"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equations-of-motion","text":"Using Newton\u2019s Second Law: \\[ \\frac{d\\vec{v}}{dt} = \\frac{q}{m}(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Numerical integration will be done using solve_ivp from SciPy.","title":"Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Constants q = 1 # Charge in Coulombs m = 1 # Mass in kilograms (1 kg) B = np.array([0, 0, 1]) # Magnetic field in z-direction E = np.array([0, 5, 0]) # Electric field in y-direction # Lorentz force system def lorentz(t, y, use_electric=False): r = y[:3] v = y[3:] E_field = E if use_electric else np.array([0, 0, 0]) a = (q / m) * (E_field + np.cross(v, B)) return np.concatenate((v, a)) # Time settings dt = 1e-3 n_steps = 5000 T = dt * n_steps t_eval = np.linspace(0, T, n_steps) # Define all 3 scenarios configs = [ { \"label\": \"Circular Trajectory in Magnetic Field\", \"y0\": [0, 0, 0, 10, 0, 0], # Initial velocity in X \"use_electric\": False }, { \"label\": \"Spiral Trajectory (Z motion)\", \"y0\": [0, 0, 0, 10, 0, 2], # Initial velocity in X and Z \"use_electric\": False }, { \"label\": \"E \u00d7 B Drift\", \"y0\": [0, 0, 0, 10, 0, 0], # Initial velocity in X, electric field active \"use_electric\": True } ] # Plotting fig = plt.figure(figsize=(18, 5)) for i, config in enumerate(configs): sol = solve_ivp( lorentz, [0, T], config[\"y0\"], args=(config[\"use_electric\"],), t_eval=t_eval ) x, y, z = sol.y[0], sol.y[1], sol.y[2] ax = fig.add_subplot(1, 3, i+1, projection='3d') ax.plot(x, y, z, color='deepskyblue', lw=1.5) ax.set_title(config[\"label\"], fontsize=11) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.tick_params(labelsize=8) ax.set_xlim([min(x), max(x)]) ax.set_ylim([min(y), max(y)]) ax.set_zlim([min(z), max(z)]) ax.grid(True) plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualized-results","text":"Circular motion : Pure rotation in XY-plane under magnetic field only. Spiral motion : Z-velocity added causes a spiral up. Drift motion : Crossed E and B fields result in sideways drift. Each trajectory exhibits expected motion per Lorentz force dynamics.","title":"Visualized Results"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-applications","text":"Cyclotron : Particles spiral in a magnetic field. Plasma confinement : Drift motion used in tokamaks. Mass spectrometry : Circular/spiral paths reveal charge-to-mass ratio.","title":"Real-World Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extension-ideas","text":"Add time-varying fields. Use non-uniform magnetic field. Animate the particle motion.","title":"Extension Ideas"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#colab-link","text":"Colab Notebook - Lorentz Force Simulation","title":"Colab Link"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Statistics Problem 1 Exploring the Central Limit Theorem (CLT) Motivation The Central Limit Theorem (CLT) states: Regardless of the population distribution, the distribution of the sample mean tends to a normal distribution as the sample size increases. This is foundational in statistics and useful in many real-world applications like: Estimating population parameters Quality control in manufacturing Risk modeling in finance Objective We will simulate sampling from various distributions and observe how the sampling distribution of the mean approaches normality as the sample size increases. Population Distributions We will use the following: Uniform Distribution (0, 1) Exponential Distribution (\u03bb = 1) Binomial Distribution (n = 10, p = 0.5) Python Code import numpy as np import matplotlib.pyplot as plt import seaborn as sns def simulate_clt(distribution_func, name, **kwargs): np.random.seed(42) population = distribution_func(size=100000, **kwargs) fig, axes = plt.subplots(1, 4, figsize=(20, 4)) sample_sizes = [5, 10, 30, 50] for i, size in enumerate(sample_sizes): sample_means = [np.mean(np.random.choice(population, size)) for _ in range(1000)] sns.histplot(sample_means, kde=True, ax=axes[i], stat=\"density\", bins=30, color='skyblue') axes[i].set_title(f\"{name}\\nSample size = {size}\") axes[i].set_xlabel(\"Sample Mean\") axes[i].set_ylabel(\"Density\") plt.suptitle(f\"Sampling Distribution of the Mean for {name}\", fontsize=16) plt.tight_layout() plt.show() simulate_clt(np.random.uniform, \"Uniform (0,1)\", low=0, high=1) simulate_clt(np.random.exponential, \"Exponential (\u03bb=1)\", scale=1) simulate_clt(np.random.binomial, \"Binomial (n=10, p=0.5)\", n=10, p=0.5) Observations and Insights As sample size increases, histograms become more bell-shaped. Even for skewed distributions (like exponential), the sample mean becomes nearly normal. CLT works surprisingly well even for n = 30. Larger sample size \u2192 smaller variance of sample mean. Definitions Sample Mean ( \\(\\bar{x}\\) ) : The average of a sample. Sampling Distribution : The distribution of a statistic (e.g., mean) over repeated samples. Variance of Sample Mean : \\(\\frac{\\sigma^2}{n}\\) , where \\(\\sigma^2\\) is the population variance. Population Distribution : The underlying distribution from which samples are drawn. Skewness : Asymmetry in the distribution. Real-World Applications of CLT Estimating average weights, heights, or scores from samples. Quality control processes that rely on sample batch tests. Predicting average customer behavior in marketing. Financial forecasts based on sampled historical data. Designing experiments and interpreting A/B tests. Conclusion The Central Limit Theorem is powerful: regardless of how skewed or irregular the original population is, the distribution of the sample mean tends to normal as sample size increases. This gives us confidence in using normal-based inference (confidence intervals, hypothesis tests) even when the original data is not normal \u2014 as long as the sample size is large enough Colab Link Statistics","title":"Statistics Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#statistics-problem-1","text":"","title":"Statistics Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-clt","text":"","title":"Exploring the Central Limit Theorem (CLT)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) states: Regardless of the population distribution, the distribution of the sample mean tends to a normal distribution as the sample size increases. This is foundational in statistics and useful in many real-world applications like: Estimating population parameters Quality control in manufacturing Risk modeling in finance","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"We will simulate sampling from various distributions and observe how the sampling distribution of the mean approaches normality as the sample size increases.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-distributions","text":"We will use the following: Uniform Distribution (0, 1) Exponential Distribution (\u03bb = 1) Binomial Distribution (n = 10, p = 0.5)","title":"Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns def simulate_clt(distribution_func, name, **kwargs): np.random.seed(42) population = distribution_func(size=100000, **kwargs) fig, axes = plt.subplots(1, 4, figsize=(20, 4)) sample_sizes = [5, 10, 30, 50] for i, size in enumerate(sample_sizes): sample_means = [np.mean(np.random.choice(population, size)) for _ in range(1000)] sns.histplot(sample_means, kde=True, ax=axes[i], stat=\"density\", bins=30, color='skyblue') axes[i].set_title(f\"{name}\\nSample size = {size}\") axes[i].set_xlabel(\"Sample Mean\") axes[i].set_ylabel(\"Density\") plt.suptitle(f\"Sampling Distribution of the Mean for {name}\", fontsize=16) plt.tight_layout() plt.show() simulate_clt(np.random.uniform, \"Uniform (0,1)\", low=0, high=1) simulate_clt(np.random.exponential, \"Exponential (\u03bb=1)\", scale=1) simulate_clt(np.random.binomial, \"Binomial (n=10, p=0.5)\", n=10, p=0.5)","title":"Python Code"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations-and-insights","text":"As sample size increases, histograms become more bell-shaped. Even for skewed distributions (like exponential), the sample mean becomes nearly normal. CLT works surprisingly well even for n = 30. Larger sample size \u2192 smaller variance of sample mean.","title":"Observations and Insights"},{"location":"1%20Physics/6%20Statistics/Problem_1/#definitions","text":"Sample Mean ( \\(\\bar{x}\\) ) : The average of a sample. Sampling Distribution : The distribution of a statistic (e.g., mean) over repeated samples. Variance of Sample Mean : \\(\\frac{\\sigma^2}{n}\\) , where \\(\\sigma^2\\) is the population variance. Population Distribution : The underlying distribution from which samples are drawn. Skewness : Asymmetry in the distribution.","title":"Definitions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-applications-of-clt","text":"Estimating average weights, heights, or scores from samples. Quality control processes that rely on sample batch tests. Predicting average customer behavior in marketing. Financial forecasts based on sampled historical data. Designing experiments and interpreting A/B tests.","title":"Real-World Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"The Central Limit Theorem is powerful: regardless of how skewed or irregular the original population is, the distribution of the sample mean tends to normal as sample size increases. This gives us confidence in using normal-based inference (confidence intervals, hypothesis tests) even when the original data is not normal \u2014 as long as the sample size is large enough","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#colab-link","text":"Statistics","title":"Colab Link"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Statistics Problem 2 Estimating \u03c0 Using Monte Carlo Methods Motivation Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One elegant use case is estimating the value of \u03c0 through geometric probability. By simulating random events like point placements or needle drops, we can explore how \u03c0 emerges from probability. This simulation-based approach connects key concepts in probability, geometry, and computation. Part 1: Estimating \u03c0 Using a Circle Theoretical Foundation If we inscribe a unit circle in a 2x2 square and throw random points in the square, the ratio of points that fall inside the circle to the total number of points approximates the area ratio: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Points Inside Circle}}{\\text{Total Points}} \\] Simulation Code (Circle) import numpy as np import matplotlib.pyplot as plt np.random.seed(42) N = 10000 x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) dist = np.sqrt(x**2 + y**2) inside = dist <= 1 pi_estimate = 4 * np.sum(inside) / N print(f\"Estimated \u03c0: {pi_estimate:.5f}\") plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.title(f'Monte Carlo Estimation of \u03c0\\nEstimate: {pi_estimate:.5f}') plt.legend() plt.gca().set_aspect('equal') plt.grid(True) plt.show() Visualization Blue dots = inside unit circle Red dots = outside circle As N increases, convergence to \u03c0 improves Part 2: Estimating \u03c0 Using Buffon\u2019s Needle Theoretical Foundation Buffon's Needle experiment estimates \u03c0 based on geometric probability: \\[ \\pi \\approx \\frac{2 \\cdot L \\cdot N}{t \\cdot C} \\] Where: L: length of the needle t: distance between parallel lines N: number of throws C: number of crossings Simulation Code (Buffon\u2019s Needle) import numpy as np np.random.seed(1) L = 1.0 # needle length t = 2.0 # distance between lines N = 100000 crossings = 0 for _ in range(N): center = np.random.uniform(0, t/2) angle = np.random.uniform(0, np.pi/2) if center <= (L/2)*np.sin(angle): crossings += 1 if crossings > 0: pi_buffon = (2 * L * N) / (t * crossings) print(f\"Estimated \u03c0 via Buffon\u2019s Needle: {pi_buffon:.5f}\") else: print(\"No crossings detected\") Estimated \u03c0 via Buffon\u2019s Needle: 3.13087 import matplotlib.pyplot as plt import numpy as np # Re-run the simulation to store individual needle data for visualization L = 1.0 # needle length t = 2.0 # distance between lines N_viz = 1000 # Reduce N for visualization to avoid overcrowding the plot crossings_viz = 0 needle_data = [] # Store (center, angle, crossed) for each needle np.random.seed(1) # Use the same seed for reproducibility for _ in range(N_viz): center = np.random.uniform(0, t/2) angle = np.random.uniform(0, np.pi/2) crossed = center <= (L/2)*np.sin(angle) if crossed: crossings_viz += 1 needle_data.append((center, angle, crossed)) # Create the plot plt.figure(figsize=(8, 6)) # Draw the lines plt.axhline(y=0, color='black', linestyle='-') plt.axhline(y=t/2, color='black', linestyle='-') # Plot the needles for center, angle, crossed in needle_data: x_start = -L/2 * np.cos(angle) y_start = center - L/2 * np.sin(angle) x_end = L/2 * np.cos(angle) y_end = center + L/2 * np.sin(angle) color = 'red' if crossed else 'blue' plt.plot([x_start, x_end], [y_start, y_end], color=color, linewidth=0.5) plt.xlabel(\"Needle X Position\") plt.ylabel(\"Needle Y Position (Distance from bottom line)\") plt.title(f\"Buffon's Needle Simulation ({N_viz} needles)\") plt.ylim(-L/2, t/2 + L/2) # Adjust y-limits to show the whole needle plt.xlim(-L/2, L/2) # Adjust x-limits plt.gca().set_aspect('equal', adjustable='box') # Set aspect ratio to equal plt.show() if crossings_viz > 0: pi_buffon_viz = (2 * L * N_viz) / (t * crossings_viz) print(f\"Estimated \u03c0 via Buffon\u2019s Needle (Visualization subset): {pi_buffon_viz:.5f}\") else: print(\"No crossings detected in visualization subset\") Colab Visualization You can simulate and visualize needle positions using matplotlib to show how often they cross the lines. Observations and Analysis Convergence : The circle method converges more quickly than Buffon\u2019s Needle. Accuracy : Buffon\u2019s Needle can be noisy for small sample sizes. Comparison : Both rely on large N, but geometric randomness in Buffon\u2019s is less efficient. Definitions Monte Carlo Simulation : A method relying on random sampling to compute numerical estimates. Geometric Probability : Estimation based on spatial geometry and randomness. Convergence : How fast the simulation estimate approaches the true value. Real-World Applications Estimating physical constants Simulations in finance and risk analysis Geometry-based probability models Performance benchmarking in numerical algorithms Conclusion Monte Carlo methods are intuitive and powerful for demonstrating how randomness can solve real mathematical problems. Estimating \u03c0 highlights the role of probability in computation. Colab Link Colab Notebook - Monte Carlo Estimation of \u03c0","title":"Statistics Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#statistics-problem-2","text":"","title":"Statistics Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One elegant use case is estimating the value of \u03c0 through geometric probability. By simulating random events like point placements or needle drops, we can explore how \u03c0 emerges from probability. This simulation-based approach connects key concepts in probability, geometry, and computation.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"If we inscribe a unit circle in a 2x2 square and throw random points in the square, the ratio of points that fall inside the circle to the total number of points approximates the area ratio: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Points Inside Circle}}{\\text{Total Points}} \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-code-circle","text":"import numpy as np import matplotlib.pyplot as plt np.random.seed(42) N = 10000 x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) dist = np.sqrt(x**2 + y**2) inside = dist <= 1 pi_estimate = 4 * np.sum(inside) / N print(f\"Estimated \u03c0: {pi_estimate:.5f}\") plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.title(f'Monte Carlo Estimation of \u03c0\\nEstimate: {pi_estimate:.5f}') plt.legend() plt.gca().set_aspect('equal') plt.grid(True) plt.show()","title":"Simulation Code (Circle)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization","text":"Blue dots = inside unit circle Red dots = outside circle As N increases, convergence to \u03c0 improves","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon's Needle experiment estimates \u03c0 based on geometric probability: \\[ \\pi \\approx \\frac{2 \\cdot L \\cdot N}{t \\cdot C} \\] Where: L: length of the needle t: distance between parallel lines N: number of throws C: number of crossings","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-code-buffons-needle","text":"import numpy as np np.random.seed(1) L = 1.0 # needle length t = 2.0 # distance between lines N = 100000 crossings = 0 for _ in range(N): center = np.random.uniform(0, t/2) angle = np.random.uniform(0, np.pi/2) if center <= (L/2)*np.sin(angle): crossings += 1 if crossings > 0: pi_buffon = (2 * L * N) / (t * crossings) print(f\"Estimated \u03c0 via Buffon\u2019s Needle: {pi_buffon:.5f}\") else: print(\"No crossings detected\") Estimated \u03c0 via Buffon\u2019s Needle: 3.13087 import matplotlib.pyplot as plt import numpy as np # Re-run the simulation to store individual needle data for visualization L = 1.0 # needle length t = 2.0 # distance between lines N_viz = 1000 # Reduce N for visualization to avoid overcrowding the plot crossings_viz = 0 needle_data = [] # Store (center, angle, crossed) for each needle np.random.seed(1) # Use the same seed for reproducibility for _ in range(N_viz): center = np.random.uniform(0, t/2) angle = np.random.uniform(0, np.pi/2) crossed = center <= (L/2)*np.sin(angle) if crossed: crossings_viz += 1 needle_data.append((center, angle, crossed)) # Create the plot plt.figure(figsize=(8, 6)) # Draw the lines plt.axhline(y=0, color='black', linestyle='-') plt.axhline(y=t/2, color='black', linestyle='-') # Plot the needles for center, angle, crossed in needle_data: x_start = -L/2 * np.cos(angle) y_start = center - L/2 * np.sin(angle) x_end = L/2 * np.cos(angle) y_end = center + L/2 * np.sin(angle) color = 'red' if crossed else 'blue' plt.plot([x_start, x_end], [y_start, y_end], color=color, linewidth=0.5) plt.xlabel(\"Needle X Position\") plt.ylabel(\"Needle Y Position (Distance from bottom line)\") plt.title(f\"Buffon's Needle Simulation ({N_viz} needles)\") plt.ylim(-L/2, t/2 + L/2) # Adjust y-limits to show the whole needle plt.xlim(-L/2, L/2) # Adjust x-limits plt.gca().set_aspect('equal', adjustable='box') # Set aspect ratio to equal plt.show() if crossings_viz > 0: pi_buffon_viz = (2 * L * N_viz) / (t * crossings_viz) print(f\"Estimated \u03c0 via Buffon\u2019s Needle (Visualization subset): {pi_buffon_viz:.5f}\") else: print(\"No crossings detected in visualization subset\") Colab","title":"Simulation Code (Buffon\u2019s Needle)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization_1","text":"You can simulate and visualize needle positions using matplotlib to show how often they cross the lines.","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#observations-and-analysis","text":"Convergence : The circle method converges more quickly than Buffon\u2019s Needle. Accuracy : Buffon\u2019s Needle can be noisy for small sample sizes. Comparison : Both rely on large N, but geometric randomness in Buffon\u2019s is less efficient.","title":"Observations and Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#definitions","text":"Monte Carlo Simulation : A method relying on random sampling to compute numerical estimates. Geometric Probability : Estimation based on spatial geometry and randomness. Convergence : How fast the simulation estimate approaches the true value.","title":"Definitions"},{"location":"1%20Physics/6%20Statistics/Problem_2/#real-world-applications","text":"Estimating physical constants Simulations in finance and risk analysis Geometry-based probability models Performance benchmarking in numerical algorithms","title":"Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Monte Carlo methods are intuitive and powerful for demonstrating how randomness can solve real mathematical problems. Estimating \u03c0 highlights the role of probability in computation.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/#colab-link","text":"Colab Notebook - Monte Carlo Estimation of \u03c0","title":"Colab Link"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}