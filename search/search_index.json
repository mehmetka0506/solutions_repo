{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, though seemingly simple, presents a deep and rich structure when examined thoroughly. By studying how the range of a projectile depends on the launch angle, we reveal fundamental principles of kinematics and dynamics. Variables like initial velocity, gravitational acceleration, and launch height provide a broad variety of solutions, applicable to real-world situations such as sports, engineering, and space science. Theoretical Foundation Starting from the basic laws of motion, we can derive the projectile equations. Assume no air resistance and flat terrain. Let: \\(v_0\\) = Initial velocity \\(\\theta\\) = Angle of projection \\(g\\) = Gravitational acceleration The equations of motion are: $$ \\frac{d^2x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) $$ \\[ \\frac{d^2y}{dt^2} = -g \\quad \\Rightarrow \\quad \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\] Integrating these: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] Time of Flight Setting \\(y = 0\\) at landing: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2}gT^2 \\] Solving for T \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range Horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum Height The maximum vertical position: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] Observations Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , that is, \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effects of parameters \\(v_0\\) : Range increases quadratically with initial velocity. \\(g\\) : Range decreases inversely with gravitational acceleration. Launch height: Would modify the symmetry and the optimal angle if included. Practical Applications Sports: Finding the best launch angles for throws, shots, or kicks. Engineering: Ballistics calculations. Astrophysics: Launching satellites or projectiles from planetary surfaces. Including air resistance, wind, or launching from non-level terrain are real-world complications addressed with numerical methods. Implementation Below are Python scripts simulating projectile motion under the given scenarios. import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f' \\(v_0\\) = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 1: 45\u00b0 angle, different velocities (30, 40, 50 m/s) python import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f' \\(v_0\\) = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 2: 50 m/s, different angles (15\u00b0, 45\u00b0, 75\u00b0) python angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f' \\(\\\\theta\\) = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representations In the first plot, as initial velocity increases, range increases significantly. angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f' \\(\\\\theta\\) = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() In the second plot, \\(45^\\circ\\) provides the maximum range, while \\(15^\\circ\\) and \\(75^\\circ\\) give the same (shorter) range. Limitations and Extensions Limitations No air resistance considered. Flat launch and landing height assumed. Extensions Include air resistance: drag force proportional to velocity. Launch from or land on elevated platforms. Add wind effects. Summary Analyzing projectile motion illustrates fundamental physics while also introducing opportunities for deeper exploration using computational methods. Studying range as a function of launch angle helps us understand both idealized and real-world trajectories. Colab Link Colab - Problem 1 Simulation","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, though seemingly simple, presents a deep and rich structure when examined thoroughly. By studying how the range of a projectile depends on the launch angle, we reveal fundamental principles of kinematics and dynamics. Variables like initial velocity, gravitational acceleration, and launch height provide a broad variety of solutions, applicable to real-world situations such as sports, engineering, and space science.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"Starting from the basic laws of motion, we can derive the projectile equations. Assume no air resistance and flat terrain. Let: \\(v_0\\) = Initial velocity \\(\\theta\\) = Angle of projection \\(g\\) = Gravitational acceleration The equations of motion are: $$ \\frac{d^2x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) $$ \\[ \\frac{d^2y}{dt^2} = -g \\quad \\Rightarrow \\quad \\frac{dy}{dt} = v_0 \\sin(\\theta) - gt \\] Integrating these: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Setting \\(y = 0\\) at landing: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2}gT^2 \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solving-for-t","text":"\\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\]","title":"Solving for T"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"Horizontal distance covered: \\[ R = v_0 \\cos(\\theta) T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#maximum-height","text":"The maximum vertical position: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , that is, \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effects of parameters \\(v_0\\) : Range increases quadratically with initial velocity. \\(g\\) : Range decreases inversely with gravitational acceleration. Launch height: Would modify the symmetry and the optimal angle if included. Practical Applications Sports: Finding the best launch angles for throws, shots, or kicks. Engineering: Ballistics calculations. Astrophysics: Launching satellites or projectiles from planetary surfaces. Including air resistance, wind, or launching from non-level terrain are real-world complications addressed with numerical methods.","title":"Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"Below are Python scripts simulating projectile motion under the given scenarios. import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f' \\(v_0\\) = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 1: 45\u00b0 angle, different velocities (30, 40, 50 m/s) python import numpy as np import matplotlib.pyplot as plt def projectile(v0, angle_deg, g=9.81): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y velocities = [30, 40, 50] angle = 45 plt.figure(figsize=(10,6)) for v0 in velocities: x, y = projectile(v0, angle) plt.plot(x, y, label=f' \\(v_0\\) = {v0} m/s') plt.title(\"Projectile Motion at 45\u00b0 with Different Velocities\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Scenario 2: 50 m/s, different angles (15\u00b0, 45\u00b0, 75\u00b0) python angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f' \\(\\\\theta\\) = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representations In the first plot, as initial velocity increases, range increases significantly. angles = [15, 45, 75] v0 = 50 plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(v0, angle) plt.plot(x, y, label=f' \\(\\\\theta\\) = {angle}\u00b0') plt.title(\"Projectile Motion at 50 m/s with Different Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() In the second plot, \\(45^\\circ\\) provides the maximum range, while \\(15^\\circ\\) and \\(75^\\circ\\) give the same (shorter) range.","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"Limitations No air resistance considered. Flat launch and landing height assumed. Extensions Include air resistance: drag force proportional to velocity. Launch from or land on elevated platforms. Add wind effects.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Analyzing projectile motion illustrates fundamental physics while also introducing opportunities for deeper exploration using computational methods. Studying range as a function of launch angle helps us understand both idealized and real-world trajectories.","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab-link","text":"Colab - Problem 1 Simulation","title":"Colab Link"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Dynamics of a Forced Damped Pendulum: A Computational Exploration Motivation The forced damped pendulum is a key system in nonlinear dynamics. When damping and external periodic forces act on a pendulum, its behavior ranges from predictable oscillations to complex and chaotic motion. This diversity reflects many real-world systems \u2014 from electronics to biomechanics. By tuning parameters like the damping factor and the strength and frequency of the driving force, we observe phenomena such as resonance, quasiperiodicity, and transitions to chaos. These insights are fundamental in understanding oscillatory systems in engineering, physics, and nature. 1. Mathematical Framework Differential Equation The system is modeled by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement - \\(b\\) : damping coefficient - \\(g\\) : gravitational acceleration - \\(L\\) : length of pendulum - \\(A\\) : external driving amplitude - \\(\\omega\\) : angular frequency of the driving force Linear Approximation (Small Angle) For small angular displacements: \\[ \\sin\\theta \\approx \\theta \\] Reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This linear form simplifies simulation and helps analyze regular behavior before chaos emerges. 2. Parameter-Based Behavior Analysis We analyze system behavior by varying: Damping coefficient \\(b\\) Driving amplitude \\(A\\) Driving frequency \\(\\omega\\) This helps reveal: - Transition from underdamped to overdamped behavior - Resonance and amplification - Onset of chaotic regimes 3. Real-World Relevance This model describes: - Suspension systems in vehicles - Oscillating electrical circuits (e.g., RLC) - Structures under periodic stress - Biological movement patterns (gait dynamics) 4. Python Modeling Below is a simulation using solve_ivp from scipy.integrate to model pendulum behavior for different conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def dynamics(t, y, b, g, L, A, omega): theta, omega_ = y return [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] # Setup y0 = [0.15, 0.0] t_range = (0, 60) t_eval = np.linspace(*t_range, 1500) cases = [ {\"label\": \"Light Damping\", \"b\": 0.1, \"A\": 0.8, \"omega\": 1.0, \"color\": \"royalblue\"}, {\"label\": \"Critical Damping\", \"b\": 0.6, \"A\": 0.8, \"omega\": 1.0, \"color\": \"firebrick\"}, {\"label\": \"High Drive\", \"b\": 0.3, \"A\": 1.8, \"omega\": 3.0, \"color\": \"darkgreen\"}, ] g = 9.8 L = 1.0 fig, axes = plt.subplots(len(cases), 2, figsize=(12, 11)) for i, c in enumerate(cases): sol = solve_ivp( dynamics, t_range, y0, args=(c[\"b\"], g, L, c[\"A\"], c[\"omega\"]), t_eval=t_eval ) theta, omega_ = sol.y axes[i, 0].plot(sol.t, theta, color=c[\"color\"]) axes[i, 0].set_title(f'{c[\"label\"]} - \u03b8(t)') axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"\u03b8 (rad)\") axes[i, 0].grid() axes[i, 1].plot(theta, omega_, color=c[\"color\"]) axes[i, 1].set_title(f'{c[\"label\"]} - Phase Diagram') axes[i, 1].set_xlabel(\"\u03b8 (rad)\") axes[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axes[i, 1].grid() plt.tight_layout() plt.show() <<<<<<< HEAD ======= - 5. Simulation Outcomes Light Damping - Oscillations persist - Phase plot shows large elliptical orbits Critical Damping - Motion stabilizes quickly - System returns to equilibrium smoothly High Drive - Complex motion develops - Phase space suggests early chaos 6. Summary and Future Work This experiment demonstrates how driven damped pendulums can show both stability and complexity, depending on parameters. Possible extensions: - Generate bifurcation diagrams for varying \\(\\omega\\) - Add nonlinear damping - Analyze long-term chaos with Poincar\u00e9 maps These tools help bridge theory with systems seen in engineering, nature, and modern physics.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#dynamics-of-a-forced-damped-pendulum-a-computational-exploration","text":"","title":"Dynamics of a Forced Damped Pendulum: A Computational Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a key system in nonlinear dynamics. When damping and external periodic forces act on a pendulum, its behavior ranges from predictable oscillations to complex and chaotic motion. This diversity reflects many real-world systems \u2014 from electronics to biomechanics. By tuning parameters like the damping factor and the strength and frequency of the driving force, we observe phenomena such as resonance, quasiperiodicity, and transitions to chaos. These insights are fundamental in understanding oscillatory systems in engineering, physics, and nature.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-mathematical-framework","text":"","title":"1. Mathematical Framework"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The system is modeled by the second-order nonlinear ODE: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement - \\(b\\) : damping coefficient - \\(g\\) : gravitational acceleration - \\(L\\) : length of pendulum - \\(A\\) : external driving amplitude - \\(\\omega\\) : angular frequency of the driving force","title":"Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#linear-approximation-small-angle","text":"For small angular displacements: \\[ \\sin\\theta \\approx \\theta \\] Reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This linear form simplifies simulation and helps analyze regular behavior before chaos emerges.","title":"Linear Approximation (Small Angle)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-parameter-based-behavior-analysis","text":"We analyze system behavior by varying: Damping coefficient \\(b\\) Driving amplitude \\(A\\) Driving frequency \\(\\omega\\) This helps reveal: - Transition from underdamped to overdamped behavior - Resonance and amplification - Onset of chaotic regimes","title":"2. Parameter-Based Behavior Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-relevance","text":"This model describes: - Suspension systems in vehicles - Oscillating electrical circuits (e.g., RLC) - Structures under periodic stress - Biological movement patterns (gait dynamics)","title":"3. Real-World Relevance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-modeling","text":"Below is a simulation using solve_ivp from scipy.integrate to model pendulum behavior for different conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def dynamics(t, y, b, g, L, A, omega): theta, omega_ = y return [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] # Setup y0 = [0.15, 0.0] t_range = (0, 60) t_eval = np.linspace(*t_range, 1500) cases = [ {\"label\": \"Light Damping\", \"b\": 0.1, \"A\": 0.8, \"omega\": 1.0, \"color\": \"royalblue\"}, {\"label\": \"Critical Damping\", \"b\": 0.6, \"A\": 0.8, \"omega\": 1.0, \"color\": \"firebrick\"}, {\"label\": \"High Drive\", \"b\": 0.3, \"A\": 1.8, \"omega\": 3.0, \"color\": \"darkgreen\"}, ] g = 9.8 L = 1.0 fig, axes = plt.subplots(len(cases), 2, figsize=(12, 11)) for i, c in enumerate(cases): sol = solve_ivp( dynamics, t_range, y0, args=(c[\"b\"], g, L, c[\"A\"], c[\"omega\"]), t_eval=t_eval ) theta, omega_ = sol.y axes[i, 0].plot(sol.t, theta, color=c[\"color\"]) axes[i, 0].set_title(f'{c[\"label\"]} - \u03b8(t)') axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"\u03b8 (rad)\") axes[i, 0].grid() axes[i, 1].plot(theta, omega_, color=c[\"color\"]) axes[i, 1].set_title(f'{c[\"label\"]} - Phase Diagram') axes[i, 1].set_xlabel(\"\u03b8 (rad)\") axes[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axes[i, 1].grid() plt.tight_layout() plt.show() <<<<<<< HEAD ======= -","title":"4. Python Modeling"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-simulation-outcomes","text":"Light Damping - Oscillations persist - Phase plot shows large elliptical orbits Critical Damping - Motion stabilizes quickly - System returns to equilibrium smoothly High Drive - Complex motion develops - Phase space suggests early chaos","title":"5. Simulation Outcomes"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-summary-and-future-work","text":"This experiment demonstrates how driven damped pendulums can show both stability and complexity, depending on parameters. Possible extensions: - Generate bifurcation diagrams for varying \\(\\omega\\) - Add nonlinear damping - Analyze long-term chaos with Poincar\u00e9 maps These tools help bridge theory with systems seen in engineering, nature, and modern physics.","title":"6. Summary and Future Work"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law states that the square of the orbital period ( \\(T^2\\) ) of a planet is proportional to the cube of the orbital radius ( \\(r^3\\) ). This relationship is fundamental in celestial mechanics and plays a critical role in our understanding of gravitational forces and planetary motion. Derivation of the Relationship For a body orbiting another significantly larger body in a circular orbit, gravitational force provides the required centripetal force: Simplifying by \\(m\\) : Thus, the orbital velocity \\(v\\) is: The orbital period \\(T\\) (one full orbit) is distance divided by velocity: Substituting the velocity expression: Simplifying further: Squaring both sides gives Kepler\u2019s third law explicitly: This shows clearly the proportionality \\(T^2 \\propto r^3\\) . Implications for Astronomy This law is crucial because it allows astronomers to: Determine planetary masses: If orbital radius and period are known, the central body's mass can be calculated. Calculate distances: Observing the orbital period helps astronomers deduce distances between celestial bodies. For instance, by measuring the Moon\u2019s orbital period around Earth and its orbital radius, Earth\u2019s mass can be accurately determined. Real-world Examples Celestial Body Orbital Radius (m) Orbital Period (days) Moon around Earth \\(3.84 \\times 10^8\\) \\(27.3\\) Earth around Sun \\(1.496 \\times 10^{11}\\) \\(365.25\\) These observed values consistently validate Kepler's Third Law. Computational Model (Python Simulation) Here's a Python simulation verifying Kepler\u2019s Third Law numerically, with graphical representations: import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # gravitational constant M_earth = 5.972e24 # Earth mass in kg r = 4.2e7 # Orbital radius in meters Orbital velocity and period v = np.sqrt(G * M_earth / r) T = 2 * np.pi * r / v Time series data time = np.linspace(0, T, 1000) x = r * np.cos(2 * np.pi * time / T) vx = -v * np.sin(2 * np.pi * time / T) Plotting both graphs in one figure plt.figure(figsize=(14, 6)) Time series (Position vs Time) plt.subplot(1, 2, 1) plt.plot(time, x / r, color='orange') plt.title('Time Series (X-Position vs Time)') plt.xlabel('Time (s)') plt.ylabel('X Position (normalized)') plt.grid(True) Phase Portrait (Velocity vs Position) plt.subplot(1, 2, 2) plt.plot(x / r, vx / v, color='purple') plt.title('Phase Portrait (Velocity vs Position)') plt.xlabel('Position (normalized)') plt.ylabel('Velocity (normalized)') plt.grid(True) plt.suptitle('Orbital Motion Visualization') plt.tight_layout() plt.savefig('orbital_motion.png') plt.show() Run this code to generate and save the graph as orbital_motion.png. Ensure the image is located in your working directory. Extension to Elliptical Orbits Kepler's third law also applies to elliptical orbits, using the semi-major axis \\(a\\) instead of radius \\(r\\) : This generalized form allows for accurate predictions for real planetary systems, which typically have elliptical orbits. Conclusion Kepler\u2019s Third Law provides astronomers with an essential tool for understanding celestial dynamics. Through both theoretical and computational analysis, we verify the profound connection between orbital radius and orbital period, critical in space exploration and astrophysics.","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law states that the square of the orbital period ( \\(T^2\\) ) of a planet is proportional to the cube of the orbital radius ( \\(r^3\\) ). This relationship is fundamental in celestial mechanics and plays a critical role in our understanding of gravitational forces and planetary motion. Derivation of the Relationship For a body orbiting another significantly larger body in a circular orbit, gravitational force provides the required centripetal force: Simplifying by \\(m\\) : Thus, the orbital velocity \\(v\\) is: The orbital period \\(T\\) (one full orbit) is distance divided by velocity: Substituting the velocity expression: Simplifying further: Squaring both sides gives Kepler\u2019s third law explicitly: This shows clearly the proportionality \\(T^2 \\propto r^3\\) . Implications for Astronomy This law is crucial because it allows astronomers to: Determine planetary masses: If orbital radius and period are known, the central body's mass can be calculated. Calculate distances: Observing the orbital period helps astronomers deduce distances between celestial bodies. For instance, by measuring the Moon\u2019s orbital period around Earth and its orbital radius, Earth\u2019s mass can be accurately determined. Real-world Examples Celestial Body Orbital Radius (m) Orbital Period (days) Moon around Earth \\(3.84 \\times 10^8\\) \\(27.3\\) Earth around Sun \\(1.496 \\times 10^{11}\\) \\(365.25\\) These observed values consistently validate Kepler's Third Law. Computational Model (Python Simulation) Here's a Python simulation verifying Kepler\u2019s Third Law numerically, with graphical representations: import numpy as np import matplotlib.pyplot as plt","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # gravitational constant M_earth = 5.972e24 # Earth mass in kg r = 4.2e7 # Orbital radius in meters","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-velocity-and-period","text":"v = np.sqrt(G * M_earth / r) T = 2 * np.pi * r / v","title":"Orbital velocity and period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#time-series-data","text":"time = np.linspace(0, T, 1000) x = r * np.cos(2 * np.pi * time / T) vx = -v * np.sin(2 * np.pi * time / T)","title":"Time series data"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting-both-graphs-in-one-figure","text":"plt.figure(figsize=(14, 6))","title":"Plotting both graphs in one figure"},{"location":"1%20Physics/2%20Gravity/Problem_1/#time-series-position-vs-time","text":"plt.subplot(1, 2, 1) plt.plot(time, x / r, color='orange') plt.title('Time Series (X-Position vs Time)') plt.xlabel('Time (s)') plt.ylabel('X Position (normalized)') plt.grid(True)","title":"Time series (Position vs Time)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#phase-portrait-velocity-vs-position","text":"plt.subplot(1, 2, 2) plt.plot(x / r, vx / v, color='purple') plt.title('Phase Portrait (Velocity vs Position)') plt.xlabel('Position (normalized)') plt.ylabel('Velocity (normalized)') plt.grid(True) plt.suptitle('Orbital Motion Visualization') plt.tight_layout() plt.savefig('orbital_motion.png') plt.show() Run this code to generate and save the graph as orbital_motion.png. Ensure the image is located in your working directory. Extension to Elliptical Orbits Kepler's third law also applies to elliptical orbits, using the semi-major axis \\(a\\) instead of radius \\(r\\) : This generalized form allows for accurate predictions for real planetary systems, which typically have elliptical orbits.","title":"Phase Portrait (Velocity vs Position)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law provides astronomers with an essential tool for understanding celestial dynamics. Through both theoretical and computational analysis, we verify the profound connection between orbital radius and orbital period, critical in space exploration and astrophysics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation Escape velocity and cosmic velocities are fundamental concepts in astrophysics, vital for understanding gravitational interactions and space exploration requirements. These velocities dictate the energy thresholds necessary for objects to orbit, escape, or leave a star system entirely. Definitions and Physical Meanings 1. First Cosmic Velocity (Orbital Velocity) The velocity required for a stable circular orbit around a celestial body: Second Cosmic Velocity (Escape Velocity) The minimum velocity required to escape the gravitational field of a celestial body without additional propulsion: Third Cosmic Velocity The velocity required to escape the gravitational influence of the solar system from Earth's orbit: where \\(v_{orbital,sun}\\) is Earth's orbital velocity around the Sun (~29.8 km/s). Mathematical Derivations Orbital Velocity (First Cosmic Velocity) A stable circular orbit requires gravitational force to equal centripetal force: Escape Velocity (Second Cosmic Velocity) Escape velocity comes from energy conservation, equating kinetic and gravitational potential energies: Solar Escape Velocity (Third Cosmic Velocity) The velocity needed to overcome both Earth's and the Sun\u2019s gravitational pull: Calculations for Celestial Bodies Celestial Body Radius (m) Mass (kg) Earth \\(6.371 \\times 10^6\\) \\(5.972 \\times 10^{24}\\) Mars \\(3.3895 \\times 10^6\\) \\(6.417 \\times 10^{23}\\) Jupiter \\(6.9911 \\times 10^7\\) \\(1.898 \\times 10^{27}\\) Python Simulation and Visualization import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.3895e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7} } names, orbital_velocities, escape_velocities = [], [], [] for name, props in bodies.items(): M, R = props['mass'], props['radius'] v_orbital = np.sqrt(G * M / R) v_escape = np.sqrt(2 * G * M / R) names.append(name) orbital_velocities.append(v_orbital / 1000) escape_velocities.append(v_escape / 1000) Plot x = np.arange(len(names)) width = 0.35 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width/2, orbital_velocities, width, label='Orbital Velocity (km/s)', color='skyblue') ax.bar(x + width/2, escape_velocities, width, label='Escape Velocity (km/s)', color='salmon') ax.set_ylabel('Velocity (km/s)') ax.set_title('Orbital and Escape Velocities for Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(names) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Importance in Space Exploration Launching Satellites: Orbital velocity determines the minimal speed satellites must achieve to maintain a stable orbit. Interplanetary Missions: Escape velocity guides spacecraft design, ensuring vehicles can exit Earth's gravitational field and travel to Mars, Jupiter, or beyond. Interstellar Travel: Understanding the third cosmic velocity is essential for missions intended to leave the solar system, such as Voyager 1 and 2. Conclusion Cosmic velocities significantly shape our approach to space exploration. Accurate knowledge and computational analysis of these velocities allow precise mission planning, facilitating humanity's exploration and potential colonization of other worlds.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity and cosmic velocities are fundamental concepts in astrophysics, vital for understanding gravitational interactions and space exploration requirements. These velocities dictate the energy thresholds necessary for objects to orbit, escape, or leave a star system entirely.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meanings","text":"","title":"Definitions and Physical Meanings"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The velocity required for a stable circular orbit around a celestial body: Second Cosmic Velocity (Escape Velocity) The minimum velocity required to escape the gravitational field of a celestial body without additional propulsion: Third Cosmic Velocity The velocity required to escape the gravitational influence of the solar system from Earth's orbit: where \\(v_{orbital,sun}\\) is Earth's orbital velocity around the Sun (~29.8 km/s).","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"Orbital Velocity (First Cosmic Velocity) A stable circular orbit requires gravitational force to equal centripetal force: Escape Velocity (Second Cosmic Velocity) Escape velocity comes from energy conservation, equating kinetic and gravitational potential energies: Solar Escape Velocity (Third Cosmic Velocity) The velocity needed to overcome both Earth's and the Sun\u2019s gravitational pull: Calculations for Celestial Bodies Celestial Body Radius (m) Mass (kg) Earth \\(6.371 \\times 10^6\\) \\(5.972 \\times 10^{24}\\) Mars \\(3.3895 \\times 10^6\\) \\(6.417 \\times 10^{23}\\) Jupiter \\(6.9911 \\times 10^7\\) \\(1.898 \\times 10^{27}\\) Python Simulation and Visualization import numpy as np import matplotlib.pyplot as plt","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"G = 6.67430e-11 bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6}, 'Mars': {'mass': 6.417e23, 'radius': 3.3895e6}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7} } names, orbital_velocities, escape_velocities = [], [], [] for name, props in bodies.items(): M, R = props['mass'], props['radius'] v_orbital = np.sqrt(G * M / R) v_escape = np.sqrt(2 * G * M / R) names.append(name) orbital_velocities.append(v_orbital / 1000) escape_velocities.append(v_escape / 1000)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plot","text":"x = np.arange(len(names)) width = 0.35 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width/2, orbital_velocities, width, label='Orbital Velocity (km/s)', color='skyblue') ax.bar(x + width/2, escape_velocities, width, label='Escape Velocity (km/s)', color='salmon') ax.set_ylabel('Velocity (km/s)') ax.set_title('Orbital and Escape Velocities for Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(names) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Importance in Space Exploration Launching Satellites: Orbital velocity determines the minimal speed satellites must achieve to maintain a stable orbit. Interplanetary Missions: Escape velocity guides spacecraft design, ensuring vehicles can exit Earth's gravitational field and travel to Mars, Jupiter, or beyond. Interstellar Travel: Understanding the third cosmic velocity is essential for missions intended to leave the solar system, such as Voyager 1 and 2.","title":"Plot"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Cosmic velocities significantly shape our approach to space exploration. Accurate knowledge and computational analysis of these velocities allow precise mission planning, facilitating humanity's exploration and potential colonization of other worlds.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation The trajectory of an object released from a rocket near Earth depends significantly on initial conditions such as position, altitude, and velocity. This problem integrates orbital mechanics and numerical analysis, essential for real-world applications in satellite deployment, orbital insertion, reentry strategies, and space exploration. Types of Trajectories When a payload is released near Earth, its trajectory may take one of three forms: Elliptical Trajectory: Bound orbit around Earth. Parabolic Trajectory: Exactly at escape velocity, theoretically escaping Earth\u2019s gravitational influence. Hyperbolic Trajectory: Exceeding escape velocity, permanently escaping Earth\u2019s gravitational pull. The type of trajectory depends primarily on the initial velocity relative to Earth's gravitational pull. Mathematical Analysis Using Newton\u2019s Law of Universal Gravitation: Where: \\(G\\) is gravitational constant \\(M\\) is mass of Earth \\(m\\) is payload mass (cancels out in trajectory calculations) \\(r\\) is distance from Earth\u2019s center Energy Considerations: Total mechanical energy determines the trajectory type: Elliptical: \\(E < 0\\) Parabolic: \\(E = 0\\) Hyperbolic: \\(E > 0\\) Numerical Simulation (Python) Below is a Python script to numerically simulate and visualize payload trajectories: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 Equations of motion def equations(t, y): r = np.sqrt(y[0] 2 + y[1] 2) ax = -G * M * y[0] / r 3 ay = -G * M * y[1] / r 3 return [y[2], y[3], ax, ay] Initial conditions: altitude (400km) and varying velocities altitude = 400e3 v_initial = np.sqrt(G*M/(R_earth+altitude)) # Circular orbital speed Initial conditions for elliptical, parabolic, hyperbolic trajectories initial_conditions = [ (0, R_earth + altitude, 0.8 * v_initial, 0), # Elliptical (0, R_earth + altitude, v_initial np.sqrt(2), 0), # Parabolic (0, R_earth + altitude, 1.2 * v_initial np.sqrt(2), 0) # Hyperbolic ] labels = ['Elliptical', 'Parabolic', 'Hyperbolic'] plt.figure(figsize=(10,10)) for y0, label in zip(initial_conditions, labels): sol = solve_ivp(equations, [0, 8000], y0, max_step=10) plt.plot(sol.y[0]/1e6, sol.y[1]/1e6, label=label) Earth for visualization earth = plt.Circle((0, 0), R_earth/1e6, color='blue', alpha=0.3) plt.gca().add_artist(earth) plt.xlabel('X Position (1000 km)') plt.ylabel('Y Position (1000 km)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show() Real-world Applications Orbital insertion: Payload velocity adjusted precisely for stable elliptical orbits. Satellite deployment: Payloads released at calculated velocities to achieve desired trajectories. Reentry: Adjusting velocities for payloads to safely reenter Earth\u2019s atmosphere. Interplanetary exploration: Hyperbolic trajectories employed to leave Earth's gravitational influence for missions to other planets. Conclusion Understanding and accurately calculating payload trajectories near Earth are vital in space missions. Numerical methods and simulations are essential tools for predicting and visualizing these trajectories, supporting successful mission outcomes.","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"The trajectory of an object released from a rocket near Earth depends significantly on initial conditions such as position, altitude, and velocity. This problem integrates orbital mechanics and numerical analysis, essential for real-world applications in satellite deployment, orbital insertion, reentry strategies, and space exploration.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"When a payload is released near Earth, its trajectory may take one of three forms: Elliptical Trajectory: Bound orbit around Earth. Parabolic Trajectory: Exactly at escape velocity, theoretically escaping Earth\u2019s gravitational influence. Hyperbolic Trajectory: Exceeding escape velocity, permanently escaping Earth\u2019s gravitational pull. The type of trajectory depends primarily on the initial velocity relative to Earth's gravitational pull. Mathematical Analysis Using Newton\u2019s Law of Universal Gravitation: Where: \\(G\\) is gravitational constant \\(M\\) is mass of Earth \\(m\\) is payload mass (cancels out in trajectory calculations) \\(r\\) is distance from Earth\u2019s center Energy Considerations: Total mechanical energy determines the trajectory type: Elliptical: \\(E < 0\\) Parabolic: \\(E = 0\\) Hyperbolic: \\(E > 0\\) Numerical Simulation (Python) Below is a Python script to numerically simulate and visualize payload trajectories: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"def equations(t, y): r = np.sqrt(y[0] 2 + y[1] 2) ax = -G * M * y[0] / r 3 ay = -G * M * y[1] / r 3 return [y[2], y[3], ax, ay]","title":"Equations of motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-altitude-400km-and-varying-velocities","text":"altitude = 400e3 v_initial = np.sqrt(G*M/(R_earth+altitude)) # Circular orbital speed","title":"Initial conditions: altitude (400km) and varying velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-for-elliptical-parabolic-hyperbolic-trajectories","text":"initial_conditions = [ (0, R_earth + altitude, 0.8 * v_initial, 0), # Elliptical (0, R_earth + altitude, v_initial np.sqrt(2), 0), # Parabolic (0, R_earth + altitude, 1.2 * v_initial np.sqrt(2), 0) # Hyperbolic ] labels = ['Elliptical', 'Parabolic', 'Hyperbolic'] plt.figure(figsize=(10,10)) for y0, label in zip(initial_conditions, labels): sol = solve_ivp(equations, [0, 8000], y0, max_step=10) plt.plot(sol.y[0]/1e6, sol.y[1]/1e6, label=label)","title":"Initial conditions for elliptical, parabolic, hyperbolic trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#earth-for-visualization","text":"earth = plt.Circle((0, 0), R_earth/1e6, color='blue', alpha=0.3) plt.gca().add_artist(earth) plt.xlabel('X Position (1000 km)') plt.ylabel('Y Position (1000 km)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show()","title":"Earth for visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Orbital insertion: Payload velocity adjusted precisely for stable elliptical orbits. Satellite deployment: Payloads released at calculated velocities to achieve desired trajectories. Reentry: Adjusting velocities for payloads to safely reenter Earth\u2019s atmosphere. Interplanetary exploration: Hyperbolic trajectories employed to leave Earth's gravitational influence for missions to other planets.","title":"Real-world Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Understanding and accurately calculating payload trajectories near Earth are vital in space missions. Numerical methods and simulations are essential tools for predicting and visualizing these trajectories, supporting successful mission outcomes.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}